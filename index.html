<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>BengakLearn</title>
        <link rel="stylesheet" href="style.css" />
    </head>
    <body>
        <!-- List Yang belum 
            Materi 40 MySQLi with OOP
            Materi 46 Kegunaan Reflection 
        -->
        <h1 id="title">PHP OOP</h1>
        <ul id="listitem">
            <li class="sublistitem"><strong>Learning OOP</strong></li>
            <li><a href="#1">Pengertian OOP</a></li>
            <li><a href="#2">Istilah OOP di PHP</a></li>
            <li><a href="#3">Membuat Class</a></li>
            <li><a href="#4">Instansiasi Objek</a></li>
            <li><a href="#5">Constructor dan Destructor</a></li>
            <li><a href="#6">Modifier</a></li>
            <li><a href="#7">Class Constant</a></li>
            <li><a href="#8">Class Inheritance</a></li>
            <li><a href="#9">Polymorphism</a></li>
            <li><a href="#10">Override Method</a></li>
            <li><a href="#11">Interface</a></li>
            <li><a href="#12">Abstract Class</a></li>
            <li><a href="#13">Static Method dan Properties</a></li>
            <li><a href="#14">Accesor Method</a></li>
            <li><a href="#15">Magic Method __set() dan __get()</a></li>
            <li><a href="#16">Magic Method __call()</a></li>
            <li><a href="#17">Method Chaining</a></li>
            <li><a href="#18">Namespace</a></li>
            <li><a href="#19">Autoloading Class</a></li>
            <li><a href="#20">Composer Singkat</a></li>
            <li><a href="#21">Eksistensi Class</a></li>
            <li><a href="#22">Eksistensi Method dan Property</a></li>
            <li><a href="#23">Cek Nama dan Tipe Class</a></li>
            <li><a href="#24">Clone Objek</a></li>
            <li><a href="#25">Mengubah Array Menjadi Objek</a></li>

            <li class="sublistitem"><strong>Design Pattern</strong></li>
            <li><a href="#26">Design Pattern</a></li>
            <li><a href="#27">Strategy Pattern</a></li>
            <li><a href="#28">Factory Pattern</a></li>
            <li><a href="#29">Abstract Factory</a></li>
            <li><a href="#30">Adapter Pattern</a></li>
            <li><a href="#31">Singleton Pattern</a></li>
            <li><a href="#32">Iterator Pattern</a></li>
            <li><a href="#33">Observer Pattern</a></li>
            <li><a href="#34">Proxy Pattern</a></li>
            <li><a href="#35">Decorator Pattern</a></li>
            <li><a href="#36">Active Record Pattern</a></li>
            <li><a href="#37">Facade Pattern</a></li>
            <li><a href="#38">Dependency Injection</a></li>

            <li class="sublistitem"><strong>Akses Database Dengan API PHP</strong></li>
            <li><a href="#39">Menggunakan MySQLi Procedural</a></li>
            <li><a href="#40">Menggunakan MySQLi OOP</a></li>
            <li><a href="#41">Menggunakan PDO(PHP Data Object)</a></li>

            <li class="sublistitem"><strong>PHP Exception</strong></li>
            <li><a href="#42">Penggunaan Dasar Exception</a></li>
            <li><a href="#43">Membuat Custom Exception</a></li>
            <li><a href="#44">Multiple Exception</a></li>
            <li><a href="#45">Throwable</a></li>

            <li class="sublistitem"><strong>Reflection Class</strong></li>
            <li><a href="#46">Kegunaan Reflection</a></li>
            <li><a href="#47">Reflection Method</a></li>
            <li><a href="#48">Reflection Parameter</a></li>
            <li><a href="#49">Reflection Property</a></li>

            <li class="sublistitem"><strong>Unit Testing</strong></li>
            <li><a href="#50">Menerapkan Unit Testing</a></li>
            <li><a href="#51">Mempersiapkan Unit Testing</a></li>
            <li><a href="#52">Membuat Unit Testing</a></li>
            <li><a href="#53">Simulasi Unit Testing</a></li>
            <li><a href="#54">Pengantar Test Driven Development</a></li>

            <li class="sublistitem"><strong>Tips & Trick</strong></li>
            <li><a href="#lain1">Implode</a></li>
            <li><a href="#lain2">Function Time()</a></li>
            <li><a href="#lain3">Error Reporting</a></li>
        </ul>
        <ul id="listboxmateri">
            <li class="listboxitem" id="1">
                <h2>Pengertian OOP</h2>
                <pre>
<span class="indent"></span>OOP adalah singkatan dari Object Oriented Programming. OOP sendiri merupakan metode pemrograman yang lebih berorientasi pada objek. Sehingga, akan lebih sangat memudahkan di dalam membuat aplikasi. OOP lebih di dukung pada pemrograman JAVA dan C++. Tetapi, pada PHP juga sudah sangat di dukung pada versi PHP5.

<span class="indent"></span>OOP atau yang merupakan singkatan dari object oriented programming adalah salah satu paradigma dalam pemrograman dimana kita memperlakukan kode yang kita tulis dan susun sebagai sebuah komponen yang dapat dicabut pasang dan berinteraksi antar komponen. Dibuat seunik mungkin agar suatu blok kode dapat digunakan ulang dan tidak memiliki redundansi penulisan. Serta kita juga dapat mencegah pembuatan sebuah fungsi atau prosedur yang sama tapi dimiliki oleh modul yang berbeda.

Keunggulan OOP Pada PHP
<span class="indent"></span>Kelebihan yang dimiliki OOP ini sebenarnya tidak hanya berlaku di PHP saja. Semua bahasa pemrograman juga sama efeknya. OOP diciptakan untuk mempermudah pengembangan suatu aplikasi.

<span class="indent"></span>Tujuan utama OOP adalah: semua yang ingin dilakukan, dilakukan melalui objek. Objek disini pada dasarnya adalah potongan kecil kode yang terpisah, yang dapat menggabungkan data dan beharviors secara bersama-sama. Dalam suatu aplikasi, semua objek terhubung satu sama lain, mereka berbagi data di antara mereka dan menyelesaikan masalah.

<span class="indent"></span>OOP dianggap lebih baik dari segi waktu pengembangan dan biaya pemeliharan aplikasi. Manfaat utama OOP dapat dilihat sebagai berikut:
1. Reusability
<span class="indent"></span>Objek adalah entitas yang memiliki kumpulan properti dan metode yang dapat berinteraksi dengan objek lainnya. Suatu objek biasanya memiliki ketergantungan dengan objek lain. Tetapi suatu objek biasanya dikembangkan untuk memecahkan serangkaian masalah tertentu. Jadi, ketika pengembang lain memiliki serangkaian masalah yang sama, mereka dapat menggunakan Class Anda ke Proyek mereka tanpa mempengaruhi alur kerja yang ada. Ini untuk mencegah istilah DRY (Don't Repeat Yourself). Dalam pemrograman fungsional atau modular, Reusability dimungkinkan tetapi terlalu komplek.

2. Refactoring
<span class="indent"></span>Ketika Anda perlu memperbaiki proyek, OOP memberikan manfaat maksimal. Karena, semua objek adalah entitas kecil dan mengandung properti dan metode yang merupakan bagian dari dirinya sendiri. Jadi refactoring relatif lebih mudah.

3. Extensible
<span class="indent"></span>Anda bisa memperluas objek dan membuat objek yang sama sekali baru serta mempertahankan semua properti dan metode yang diperlukan dari objek induknya dan kemudian memaparkan fitur baru. Ini biasanya disebut "Inheritance" dan ini merupakan fitur yang sangat penting dari OOP.

4. Maintenance
<span class="indent"></span>Object Oriented Code lebih mudah dipelihara karena pengkodean ditulis dengan format penjelasan sendiri. Sebagai contoh, ketika seorang pengembang ingin menambah fitur, merefaktorinnyam atau mendebugnya, mereka dapat dengan mudah mengetahui struktur pengkodean dan mempertahankan kode dari waktu ke waktu.

5. Efficiency
<span class="indent"></span>Konsep pemrograman berorientasi objek sebenarnya dikembangkan untuk efisiensi dan kemudahan proses pengembangan yang lebih baik. Beberapa pola desain dikembangkan untuk membuat kode yang lebih baik dan efisien. Selain itu di OOP, Anda dapat memikirkan solusi Anda dalam pendekatan yang jauh lebih baik daripada pemrograman prosedural.
        </pre>
            </li>
            <li class="listboxitem" id="2">
                <h2>Beberapa Istilah OOP di PHP</h2>
                <pre>
Berikut ini merupakan beberapa istilah umum OOP di PHP:

1. Class
<span class="indent"></span>Class merupakan purwarupa dari objek. Sebuah class mengandung kode program yang akan mendefinisikan bagaimana objek bekerja/berperilaku dan berinteraksi satu sama lain dengan objek lain. Setiap kali kamu membuat objek dalam PHP, kamu sebenarnya mengembangkan class. Jadi kadang-kadang dalam modul ini kita akan menamai sebuah objek sebagai class, karena keduanya sama-sama identik.

2. Property
<span class="indent"></span>Property adalah wadah di dalam class yang dapat menyimpan beberapa informasi. Tidak seperti bahasa lain, PHP tidak memeriksa jenis variabel properti. Property hanya dapat diakses di class itu sendiri, dengan subclassnya, atau oleh semua objek. Sederhananya, properti adalah variabel yang dideklarasikan di dalam class, tetapi tidak termasuk yang ada di dalam fungsi pada class.

3. Method
<span class="indent"></span>Method adalah fungsi di dalam class. Seperti properti, metode juga dapat diakses oleh ketiga jenis access modifier. Access modifier akan dijelaskan di pembahasan khusus.

4. Encapsulation
<span class="indent"></span>Enkapsulasi adalah konsep mekanisme yang mengikat kode bersama dengan data yang dimanipulasi, dan membuat keduanya aman dari kode lain yang tidak berhubungan secara langsung. Mekanisme pembungkusan data dan metode dalam satu kesatuan (yang kita sebut class) dikenal sebagai enkapsulasi.

5. Polymorphism
<span class="indent"></span>Objek bisa dari jenis apa pun. Objek diskrit dapat memiliki properti dan metode diskrit yang bekerja secara terpisah dengan objek lain. Namun seperangkat objek dapat diturunkan dari objek induk dan mempertahankan beberapa properti dari class induk. proses tersebut disebut polymorphism. Sederhananya, suatu objek dapat diubah menjadi beberapa objek lain yang mempertahankan beberapa perilakunya. Materi lebih detail terkait polymorphism di PHP dapat kamu temukan di pembahasan khusus.

6. Inheritance
<span class="indent"></span>Inheritance atau pewarisan merupakan mekanisme menurunkan/mewariskan sifat dari sebuah class ke class baru. Ketika kamu membuat class turunan dari class lain, subclass (yang diwarisi) memperoleh semua properti dan metode dari superclass (yang mewarisi). Subclass dapat menggunakan setiap metode yang ada pada superclass atau memperbaharuinya bila diperlukan yang disebut dengan istilah overriding.

7. Coupling
<span class="indent"></span>Kopling adalah perilaku bagaimana class saling bergantung satu sama lain. Arsitektur yang digabungkan secara longgar jauh lebih dapat digunakan kembali daripada objek yang digabungkan secara ketat. Coupling adalah masalah yang sangat penting untuk mendesain objek yang lebih baik.

8. Design Patterns
<span class="indent"></span>Pertama kali ditemukan oleh "Gang of Four" empat orang yang mengatur, design pattern atau pola desain hanyalah trik dalam pemrograman berorientasi objek untuk memecahkan set masalah yang sama dengan pendekatan yang lebih cerdas dan lebih mudah. Penggunaan Design Pattern (DP) dapat meningkatkan kinerja seluruh aplikasi Kamu dengan kode minimal yang ditulis oleh pengembang.

9. Subclass
<span class="indent"></span>Istilah yang sangat umum dalam OOP, dan kita akan menggunakan istilah ini di seluruh modul ini. Ketika suatu objek diturunkan dari objek lain, yang diturunkan disebut subclass dari mana ia berasal. Subclass disebut juga child class.

10. Superclass
<span class="indent"></span>Sebuah class yang disebut superclass berfungsi sebagai class induk dari satu atau beberapa subclass yang mewariskan objek. Untuk membuatnya sederhana, ketika Kamu memperluas objek, objek yang Kamu perluas adalah superclass dari objek yang baru diperluas. Superclass dikenal juga dengan istilah parent class.

11. Instance
<span class="indent"></span>Setiap kali kamu membuat objek dengan memanggil konstruktornya, itu disebut instance atau instansiasi. Sederhananya, setiap kali Kamu menulis sesuatu seperti $var = new AnyClass(); itu artinya kamu sedang membuat intance objek dari class AnyClass.
            </pre>
            </li>
            <li class="listboxitem" id="3">
                <h2>Membuat Class</h2>
                <pre>
<span class="indent"></span>Class di dalam OOP digunakan untuk membuat sebuah kerangka kerja atau blueprint. Pada PHP, class ditulis dengan awalan sintaks class dan kemudian baru diikuti dengan nama classnya. Berikut merupakan contoh penulisan class.
<pre class="code">
// Gunakan kapital diawal untuk nama kelas.
class Classname {
    // Isi dari class    
}</pre>
<strong>Anatomi Class</strong>
<span class="indent"></span>Sebuah class setidaknya membungkus beberapa komponen seperti berikut:

1. attribute, yakni variabel yang ada di dalam class. Attribute dapat diakses dari semua method di dalam class tersebut dan tidak dapat diakses dari luar class.
2. method, adalah istilah untuk function yang ada di dalam class. Sekalipun sebuah method memiliki nama yang sama dengan method di class lain, dia tidak akan dianggap sebagai method yang sama.
3. constructor, adalah method khusus yang akan selalu dieksekusi begitu sebuah class diinstansiasi atau dibuat objeknya.
<pre class="code">
class Lingkaran {

    private $radius;

    // Method __construct akan dipelajari lebih lanjut di materi kedepan
    function __construct($radius) 
    {
        $this->radius = $radius;
    }

    function hitungLuas()
    {
        return 22 / 7 * 2 * $this->radius;
    }

    function hitungKeliling()
    {
        return 22 / 7 * $this->radius * $this->radius;
    }
}
</pre>
<span class="indent"></span>Pada contoh kode di atas, $radius adalah property. Fungsi hitungLuas(), hitungKeliling() dan __construct() adalah method. Fungsu __construct() adalah fungsi khusus yang dinamakan method constructor.
                </pre>
            </li>
            <li class="listboxitem" id="4">
                <h2>Instansiasi Objek</h2>
                <pre>
<span class="indent"></span>Istilah objek dalam OOP merujuk pada hasil cetak atau hasil 'konkrit' dari class. Bila kita memiliki sebuah class Mobil, maka objectnya bisa berupa: MobilSaya, MobilKamu dan lain-lain. Object dari class Mobil akan memiliki seluruh komponen berupa property dan method dari class tersebut.

<span class="indent"></span>Proses mencetak objek dari sebuah class disebut dengan instansiasi (atau instantiation dalam bahasa inggris). Pada PHP, proses instansiasi dilakukan dengan menggunakan sintaks new. Hasil cetakan class akan disimpan dalam variabel untuk selanjutnya digunakan dalam proses pada program.

Berikut ini adalah contohnya:
<pre class="code">
class Mobil {

    private $statusBensin = false;

    public function isiBensin()
    {
        $this->statusBensin = true;
    }

    public function nyalakan()
    {
        if($this->statusBensin)
            return "Mobil menyala";

        return "Bensin habis";
    }
}

// Instansiasi object MobilSaya dari class Mobil
$MobilSaya = new Mobil();

// Menjalankan sebuah method
echo $MobilSaya->isiBensin();
echo $MobilSaya->nyalakan();
</pre>
Sebuah class baru dapat digunakan setelah dibuat ke dalam bentuk objek melalui proses instansiasi. Perhatikan kembali contoh kode berikut:

<span class="indent"></span>Sesudah sebuah class terinstansiasi, maka dia akan disimpan ke variabel yang kita gunakan. Pada kode di atas, variabelnya adalah $MobilSaya, lalu kita dapat menggunakan method yang ada di dalamnya untuk melakukan operasi yang kita inginkan.

<strong>Menggunakan Ulang Objek</strong>
Kita dapat membuat sebuah class yang objeknya dapat digunakan secara berulang. Perhatikan contoh berikut:
<pre class="code">
class Persegi {

    public $panjang;
    public $lebar;

    function __construct($panjang, $lebar) 
    {
        $this->panjang = $panjang;
        $this->lebar = $lebar;
    }

    function hitungLuas()
    {
        return $this->panjang * $this->lebar;
    }

    function hitungKeliling()
    {
        return (2 * $this->panjang) + (2 * $this->lebar);
    }
}
</pre>
<span class="indent"></span>Bila class di atas kita instansiasi, maka kita akan mendapatkan sebuah objek yang dapat digunakan untuk menghitung luas dan keliling persegi. Kita juga dapat mengatur ulang nilai property panjang dan lebar untuk perhitungan selanjutnya.
<pre class="code">
class Persegi {

    public $panjang;
    public $lebar;

    function __construct($panjang, $lebar) 
    {
        $this->panjang = $panjang;
        $this->lebar = $lebar;
    }

    function hitungLuas()
    {
        return $this->panjang * $this->lebar;
    }

    function hitungKeliling()
    {
        return (2 * $this->panjang) + (2 * $this->lebar);
    }
}

$persegi = new Persegi(10, 5);
echo "Luas: " . $persegi->hitungLuas();
echo "Keliling: " . $persegi->hitungKeliling();

// Mengatur ulang isi property
$persegi->panjang = 20;
$persegi->lebar = 12;

// Memanggil ulang method dengan properti value yang berbeda, maka hasilnya beda.
echo "Luas: " . $persegi->hitungLuas();
echo "Keliling: " . $persegi->hitungKeliling();
</pre>
<span class="indent"></span>Pada contoh kode di atas, kita set ulang property panjang dan lebar dari objek $persegi sehingga hasil perhitungan selanjutnya akan menggunakan nilai property yang baru. Dengan demikian kita tidak perlu membuat objek baru setiap kali hendak melakukan perhitungan.
                </pre>
            </li>
            <li class="listboxitem" id="5">
                <h2>Constructor dan Destructor</h2>
                <pre>
<span class="indent"></span>Tidak hanya constructor yang ada dalam suatu life cycle sebuah class. Ada juga destructor yang berperan dalam mengeksekusi kode bila ketika suatu class akan dihancurkan dari memori atau mengalami proses garbage collector.

Mari kita perhatikan contoh kode berikut:
<pre class="code">
<span class="tagphpbuka"></span>

class DB {

    private $dbConnectionStatus = "close";

    function __construct() 
    {
        $this->dbConnectionStatus = "connecting";
    }

    function connect()
    {
        $this->dbConnectionStatus = "open";
    }

    function getConnectionStatus()
    {
        return $this->dbConnectionStatus;
    }

    function __destruct()
    {
        $this->dbConnectionStatus = "close";
        echo "status: ".$this->dbConnectionStatus."<span class="tagbr"></span>";
    }
}

$db = new DB();
echo $db->getConnectionStatus(). "<span class="tagbr"></span>";
$db->connect();
echo $db->getConnectionStatus(). "<span class="tagbr"></span>";
</pre>
Bila kita jalankan akan muncul output seperti berikut:
<pre class="code">
$ php const-dest-1.php
connecting
open
status: close!
</pre>
Dengan demikian, construtor akan selalu dipanggil begitu class berhasil diinstansiasi, sedangkan destructor akan selalu dipanggil sesaat objek berhasil masuk dalam garbage collector.

<strong>Batasan Constructor</strong>
<span class="indent"></span>Selain itu constructor dari suatu class induk tidak dapat dijalankan bila tidak dipanggil dari class anak. Jadi kita harus memanggil constructor dari suatu class induk dengan cara parent::__construct() .

Mari kita perhatikan contoh kode berikut :
<pre class="code">
<span class="tagphpbuka"></span>

class Controller {

    function __construct()
    {
        echo "Ini di dalam konstruktor Controller!<span class="tagbr"></span>";
    }
}

class HomeController extends Controller {

    function __construct()
    {
        parent::__construct();
        echo "Ini di dalam konstruktor HomeController!<span class="tagbr"></span>";
    }
}

$hc = new HomeController();
</pre>
Bila kita jalankan akan muncul output seperti berikut:
<pre class="code">
$ php const-dest-2.php
Ini di dalam konstruktor Controller!
Ini di dalam konstruktor HomeController!
</pre>
Namun bila kita komentari bagian kode yang memanggil constructor induk, maka output-nya akan seperti ini:
<pre class="code">
$ php const-dest-2.php
Ini di dalam konstruktor HomeController!
</pre>
                </pre>
            </li>
            <li class="listboxitem" id="6">
                <h2>Modifier</h2>
                <pre>
<span class="indent"></span>Setiap variabel yang di dalam class atau attribute memiliki tingkat akses yang dapat diakses dari luar class atau bahkan tidak dapat diakses sama sekali. Maksudnya adalah ketika kamu mencoba mengubah isi atribut langsung tanpa melewati suatu method maka hal ini dapat kamu lakukan bila tingkat akses suatu variabel atau atribut adalah public.

Mari kita perhatikan contoh kode berikut:
<pre class="code">
<span class="tagphpbuka"></span>

class Persegi {
    public $panjang;
    public $lebar;

    function __construct($p, $l) 
    {
        $this->panjang = $p;
        $this->lebar = $l;
    }

    public function hitungLuas()
    {
        return $this->panjang * $this->lebar;
    }

    public function hitungKeliling()
    {
        return (2 * $this->panjang) + (2 * $this->lebar);
    }
}

$p = new Persegi(5, 10);

printf("Luas: %s\n", $p->hitungLuas());
printf("Keliling: %s\n", $p->hitungKeliling());

$p->panjang = 20;
$p->lebar = 30;

printf("Luas: %s\n", $p->hitungLuas());
printf("Keliling: %s\n", $p->hitungKeliling());
</pre>
<span class="indent"></span>Bisa kamu lihat pada potongan diatas, baik dari dalam method yang ada di dalam class atau dari luar class, atribut panjang dan lebar dapat diubah tanpa terjadi error apapun. Begitulah sifat tingkat akses public, dapat membuat suatu atribut diakses dari luar.

Potongan kode diatas bila kita jalankan akan muncul seperti berikut:
<pre class="code">
$ php attribute-public.php
Luas: 50
Keliling: 30
Luas: 600
Keliling: 100
</pre>
<strong>Modifier Protected</strong>
<span class="indent"></span>Sekarang kita coba untuk menelaah tingkat akses protected , tingkat akses ini hanya dapat membuat suatu atribut diakses dari class anaknya, jadi tidak dapat kita ubah nilainya dari luar class.

Mari kita perhatikan contoh kode berikut :
<pre class="code">
<span class="tagphpbuka"></span>

class Persegi {
    protected $panjang;
    protected $lebar;

    function __construct($p, $l) 
    {
        $this->panjang = $p;
        $this->lebar = $l;
    }

    public function hitungLuas()
    {
        return $this->panjang * $this->lebar;
    }

    public function hitungKeliling()
    {
        return (2 * $this->panjang) + (2 * $this->lebar);
    }
}

class Balok extends Persegi {
    public $tinggi;

    function __construct($p, $l, $t) 
    {
        $this->panjang = $p;
        $this->lebar = $l;
        $this->tinggi = $t;
    }

    public function hitungVolume()
    {
        return $this->panjang * $this->lebar * $this->tinggi;
    }

    public function hitungLuasPermukaan()
    {
        return (4 * ($this->panjang * $this->lebar ) ) + (2 * ( $this->lebar * $this->lebar ));
    }
}

$p = new Balok(5, 10, 2);

printf("Volume: %s\n", $p->hitungVolume());
printf("Luas Permukaan: %s\n", $p->hitungLuasPermukaan());

// Lepas tanda komentar di bawah baris kode berikut
// $p->panjang = 7;
// $p->lebar = 3;

$p->tinggi = 10;

printf("Volume: %s\n", $p->hitungVolume());
printf("Luas Permukaan: %s\n", $p->hitungLuasPermukaan());
</pre>
Pada potongan kode berikut kita dapat melihat ada beberapa baris yang menggunakan atribut panjang dan lebar tapi kita tidak melihat pendefinisiannya di dalam class ini:
<pre class="code">
<span class="tagphpbuka"></span>

class Balok extends Persegi {
    public $tinggi;

    function __construct($p, $l, $t) 
    {
        $this->panjang = $p;
        $this->lebar = $l;
        $this->tinggi = $t;
    }

    public function hitungVolume()
    {
        return $this->panjang * $this->lebar * $this->tinggi;
    }

    public function hitungLuasPermukaan()
    {
        return (4 * ($this->panjang * $this->lebar ) ) + (2 * ( $this->lebar * $this->lebar ));
    }
}
</pre>
Mengapa? karena kita telah menggunakan mekanisme protected dalam menggunakan atribut yang ada pada class induk.

Potongan kode diatas bila kita jalankan akan muncul seperti berikut:
<pre class="code">
$ php attribute-protected.php
Volume: 100
Luas Permukaan: 400
Volume: 500
Luas Permukaan: 400
</pre>
Sekarang mari kita buka bagian baris yang dikomentari dari kode diatas:
<pre class="code">
// Lepas tanda komentar di bawah baris kode berikut
$p->panjang = 7;
$p->lebar = 3;
</pre>
Dan bila kita jalankan maka akan muncul error berikut:
<pre class="terminal">
Volume: 100
Luas Permukaan: 400

Fatal error: Uncaught Error: Cannot access protected property Balok::$panjang in C:\xampp\htdocs\php-oop\source code\03\atribut-protected.php:52 Stack trace: #0 {main} thrown in C:\xampp\htdocs\php-oop\source code\03\atribut-protected.php on line 52
</pre>
<span class="indent"></span>Seperti yang sudah dijelaskan, karena protected dapat membuat suatu atribut hanya dapat diakses dan diubah di dalam class anak saja.

<strong>Modifier Private</strong>
<span class="indent"></span>Sekarang kita coba untuk menelaah tingkat akses private, tingkat akses ini hanya dapat membuat suatu atribut diakses dari class-nya sendiri, jadi tidak dapat kita ubah nilainya dari luar class maupun dari class anaknya.

Mari kita perhatikan contoh kode berikut:
<pre class="code">
<span class="tagphpbuka"></span>

class Car {
    private $wheel;
    private $machine;
    private $seat;

    public function setWheel($wd)
    {
        $this->wheel = $wd;
    }

    public function setMachine($machine)
    {
        $this->machine = $machine;
    }

    public function setSeat($seat)
    {
        $this->seat = $seat;
    }

    public function getWheel()
    {
        return $this->wheel;
    }

    public function getMachine()
    {
        return $this->machine;
    }

    public function getSeat()
    {
        return $this->seat;
    }
}

class Truck extends Car {

    public function __construct (){
        echo "Object Truck dibuat ...<span class="tagbr"></span>";
    }
}

class Excavator extends Car {

    public function __construct (){
        echo "Object Excavator dibuat ...<span class="tagbr"></span>";
    }
}

class SportCar extends Car {

    public function __construct (){
        echo "Object SportCar dibuat ...<span class="tagbr"></span>";
    }
}

$t = new Truck();
$t->setWheel(6);
$t->setMachine("mesin truk");
$t->setSeat(2);
echo "Wheel: ".$t->getWheel()."<span class="tagbr"></span>";
echo "Machine: ".$t->getMachine()."<span class="tagbr"></span>";
echo "Seat: ".$t->getSeat()."<span class="tagbr"></span>";

$e = new Excavator();
$e->setWheel(8);
$e->setMachine("mesin excavator");
$e->setSeat(1);

// Lepas tanda komentar di bawah baris kode berikut
//$e->wheel = 8;
//$e->seat = 6;
//print_r($e);
//echo "<span class="tagbr"></span>";

echo "Wheel: ".$e->getWheel()."<span class="tagbr"></span>";
echo "Machine: ".$e->getMachine()."<span class="tagbr"></span>";
echo "Seat: ".$e->getSeat()."<span class="tagbr"></span>";

$s = new SportCar();
$s->setWheel(4);
$s->setMachine("mesin sport car v4");
$s->setSeat(2);
echo "Wheel: ".$s->getWheel()."<span class="tagbr"></span>";
echo "Machine: ".$s->getMachine()."<span class="tagbr"></span>";
echo "Seat: ".$s->getSeat()."<span class="tagbr"></span>";
</pre>
<span class="indent"></span>Pada potongan diatas, kita menyiasati untuk pengaksesan suatu atribut private dengan membungkusnya melalui suatu method yang memiliki tingkat akses public. Tingkat akses pun tidak hanya dapat dilakukan pada atribut, juga dapat dilakukan pada suatu method.

Potongan kode diatas bila kita jalankan akan muncul seperti berikut:
<pre class="terminal">
$ php attribute-private.php
Wheel: 6
Machine: mesin truk
Seat: 2
Wheel: 8
Machine: mesin excavator
Seat: 1
Wheel: 4
Machine: mesin sport car v4
Seat: 2
</pre>
Sekarang mari kita buka bagian baris yang dikomentari dari kode diatas:
<pre class="terminal">
// Lepas tanda komentar di bawah baris kode berikut
$e->wheel = 8;
$e->seat = 6;
print_r($e);
echo "<span class="tagbr"></span>";
</pre>
Dan bila kita jalankan maka akan muncul keanehan seperti berikut:
<pre class="terminal">
Wheel: 6
Machine: mesin truk
Seat: 2
Excavator Object ( [wheel:Car:private] => 8 [machine:Car:private] => mesin excavator [seat:Car:private] => 1 [wheel] => 8 [seat] => 6 ) 
Wheel: 8
Machine: mesin excavator
Seat: 1
Wheel: 4
Machine: mesin sport car v4
Seat: 2
</pre>
Walaupun diubah dari luar, nilainya tak dapat diubah hingga ke internal objek tersebut.
                </pre>
            </li>
            <li class="listboxitem" id="7">
                <h2>Class Constant</h2>
                <pre>
<span class="indent"></span>Mudah-mudahan kamu sudah tahu bagaimana cara membuat konstanta dalam PHP menggunakan kata kunci define untuk mendefinisikan (nama konstanta dan nilai konstanta). Tetapi, untuk membuat konstanta didalam kelas, kamu harus menggunakan kata kunci const.

<span class="indent"></span>Konstanta sebenarnya berfungsi seperti variabel statis, satu-satunya perbedaan adalah bahwa mereka hanya baca atau hanya sekali mendefinisikan nilainya dan tidak dapat diubah setelah itu. Mari kita lihat bagaimana kita bisa membuat konstanta dan menggunakannya:
<pre class="code">
<span class="tagphpbuka"></span>

class HitungLingkaran
{
    const PHI = 3.14;  // Kamu gak harus pakai dollar untuk membuat konstanta
    public $jari;
    public $luas;

    // Setter jari jari.
    public function setJari($jari)
    {
        $this->jari = $jari;
    }

    public function hitung()
    {
        // Menghitung luas.
        $this->luas = self::PHI * ($this->jari ^ 2);
        return $this->luas;
    }
}
</pre>
<span class="indent"></span>Kelas diatas kita bangun untuk menghitung luas lingkaran. Kita tahu bahwa rumus luas lingkaran adalah PHI dikali jari-jari pangkat dua. Namun kita akan fokuskan pada penggunaan konstanta ya. Disitu kita define konstanta PHI tanpa dollar, lalu mengisinya dengan nilai 3.14. Selanjutnya kita panggil konstanta pada method hitung dengan self::PHI. Berbeda dengan memanggil properti lain bukan? Terlihat seperti sedang memanggil properti static dengan penggunaan double titik dua ::.

<span class="indent"></span>Selanjutnya mari kita lengkapi script diatas menjadi seperti ini :
<pre class="code">
<span class="tagphpbuka"></span>

class HitungLingkaran
{
const PHI = 3.14;  // Kamu gak harus pakai dollar untuk membuat konstanta
public $jari;
public $luas;

// Setter jari jari.
public function setJari($jari)
{
    $this->jari = $jari;
}

public function hitung()
{
    // Menghitung luas.
    $this->luas = self::PHI * ($this->jari ^ 2);
    return $this->luas;
}
}

// Kita instansiasi 
$lingkaran = new HitungLingkaran;

// Kita set jarinya.
$lingkaran->setJari(5);

// Lalu hitung
echo $lingkaran->hitung();
?>
</pre>
Output kode diatas adalah :
<pre class="terminal">
21.98
</pre>
Cukup mudah bukan? jika output keluar, selamat kamu sudah bisa menggunakan konstanta pada OOP.
                </pre>
            </li>
            <li class="listboxitem" id="8">
                <h2>Class Inheritance</h2>
                <pre>
<span class="indent"></span>Apa itu inheritance class? adalah sebuah mekanisme dimana kita dapat menggunakan variabel atau method yang dimiliki class induk kepada class anaknya. Kenapa ada mekanisme semacam ini di OOP? untuk mencegah redundansi tentunya.

<span class="indent"></span>Bayangkan bila kamu memiliki class yang method - method-nya hampir sama baik jumlah ataupun tujuannya, serta memiliki variabel yang sama juga kegunaannya. Dalam OOP kita dapat mencegah redundansi penulisan kode tersebut melalui inheritance class.

<span class="indent"></span>Sehingga nantinya class anak tidak perlu menulis ulang method yang ada di class induk selama method yang sudah tersedia masih sesuai dengan tujuan yang diperlukan. Bila tujuan sudah berbeda baik operasi, parameter, dan nilai yang dikembalikan tapi namanya masih ingin sama. Maka harus dilakukan mekanisme yang namanya overriding method.

Mari kita perhatikan contoh kode berikut:
<pre class="code">
<span class="tagphpbuka"></span>

class Hero {

    protected $healthPoint;
    protected $magicPoint;
    protected $name;

    public function sihir () {
        echo "$this->name menyerang dengan sihir<span class="tagbr"></span>";
    }

    public function serang () {
        echo "$this->name menyerang biasa<span class="tagbr"></span>";
    }

    public function tahan () {
        echo "$this->name bertahan dari serangan musuh<span class="tagbr"></span>";
    }

    public function getHealthPoint() {
        return $this->healthPoint;
    }

    public function getMagicPoint ()
    {
        return $this->magicPoint;
    }
}

class SunGoKong extends Hero {

    public function __construct()
    {
        $this->name = "Sun Go Kong";
        $this->healthPoint = 9700;
        $this->magicPoint = 1100;
    }   
}

class Susanoo extends Hero {
    public function __construct()
    {
        $this->name = "Susanoo The King of Light";
        $this->healthPoint = 9850;
        $this->magicPoint = 1280;
    }   
}

class Ogre extends Hero{
    public function __construct()
    {
        $this->name = "Ogre";
        $this->healthPoint = 8700;
        $this->magicPoint = 900;
    }   
}

$gokong = new SunGoKong();
$susanoo = new Susanoo();
$ogre = new Ogre();

$gokong->serang();
$gokong->sihir();
$gokong->tahan();
echo "HP: ".$gokong->getHealthPoint()."<span class="tagbr"></span>";
echo "MP: ".$gokong->getMagicPoint()."<span class="tagbr"></span>";

$susanoo->serang();
$susanoo->sihir();
$susanoo->tahan();
echo "HP: ".$susanoo->getHealthPoint()."<span class="tagbr"></span>";
echo "MP: ".$susanoo->getMagicPoint()."<span class="tagbr"></span>";

$ogre->serang();
$ogre->sihir();
$ogre->tahan();
echo "HP: ".$ogre->getHealthPoint()."<span class="tagbr"></span>";
echo "MP: ".$ogre->getMagicPoint()."<span class="tagbr"></span>";
</pre>
<span class="indent"></span>Kita bisa melihat sendiri kan hanya dengan menggunakan inheritance class, kita dapat membuat class dengan nama yang berbeda - beda namun dengan menggunakan sejumlah method yang sama dari class induk. Untuk melakukan ini, kita harus menggunakan keyword extends terhadap class anak dan menujuk class induk yang diinginkan.

<span class="indent"></span>Selain itu pada potongan kode diatas, kita dapat membuat beberapa class dengan nama berbeda dan default value-nya yang berbeda pula untuk menciptakan karakteristik yang tidak sama antara class yang disediakan.

Potongan kode diatas bila kita jalankan akan muncul seperti berikut:
<pre class="terminal">
$ php basic-inheritance.php
Sun Go Kong menyerang biasa
Sun Go Kong menyerang dengan sihir
Sun Go Kong bertahan dari serangan musuh
HP: 9700
MP: 1100
Susanoo The King of Light menyerang biasa
Susanoo The King of Light menyerang dengan sihir
Susanoo The King of Light bertahan dari serangan musuh
HP: 9850
MP: 1280
Ogre menyerang biasa
Ogre menyerang dengan sihir
Ogre bertahan dari serangan musuh
HP: 8700
MP: 900
</pre>
<strong>Melakukan N-Inheritance</strong>
<span class="indent"></span>Tidak berbeda jauh dengan inheritance class yang telah dipaparkan sebelumnya. Hanya saja N-Inheritance ini dilakukan terhadap class yang sudah melakukan inheritance terhadap suatu class induk. Sehingga class tersebut menjadi induk dari class lain. Atau kita dapat menganggapnya melakukan inheritance beberapa kali.

<span class="indent"></span>Inheritance macam ini biasa dilakukan bila ada suatu class yang harus dibuat generik namun dia dapat memilih siapa class induknya. Tergantung kebutuhan.

Mari kita perhatikan contoh kode berikut:
<pre class="code">
<span class="tagphpbuka"></span>

class DB {
    public function getConnection() {
        echo "Memanggil getConnection()...<span class="tagbr"></span>";
    }

    public function getConfig() {
        echo "Memanggil getConfig()...<span class="tagbr"></span>";
    }
}

class BaseModel extends DB {
    public function select () {
        echo "Melakukan query select...<span class="tagbr"></span>";
    }

    public function selectByID($id) {
        echo "Melakukan query select by id - $id...<span class="tagbr"></span>";
    }

    public function insert () {
        echo "Melakukan query insert...<span class="tagbr"></span>";
    }

    public function update () {
        echo "Melakukan query update...<span class="tagbr"></span>";
    }

    public function delete () {
        echo "Melakukan query delete...<span class="tagbr"></span>";
    }
}

class TransactionModel extends BaseModel {
    public function getDailyReport() {
        echo "Menghasilkan daily report <span class="tagbr"></span>";
    }

    public function getMonthlyReport() {
        echo "Menghasilkan monly report";
    }
}

class UserModel extends BaseModel {
    public function authenticate() {
        echo "Melakukan authentikasi user <span class="tagbr"></span>";
    }

    public function changePassword() {
        echo "Melakukan penggantian password";
    }

    public function updateProfile() {
        echo "Melakukan update password";
    }
}

$tm = new TransactionModel();
$tm->getConnection();
$tm->getConfig();
$tm->select();
$tm->selectByID(10);
$tm->insert();
$tm->update();
$tm->delete();
$tm->getDailyReport();
$tm->getMonthlyReport();

$um = new UserModel();
$um->getConnection();
$um->getConfig();
$um->select();
$um->selectByID(10);
$um->insert();
$um->update();
$um->delete();
$um->authenticate();
$um->changePassword();
$um->updateProfile();
</pre>
<span class="indent"></span>Pada kode diatas ada sebuah class bernama DB. Class tersebut kita simpan karena digunakan untuk menyimpan konfigurasi ke suatu database. Lalu ada class BaseModel yang mewarisi apa saja yang ada di class DB. Barulah setelah itu model - model yang memiliki method yang tidak sama dengan model lain mewarisi BaseModel karena pada dasarnya setiap class memiliki method yang sama untuk tujuan CRUD.

Potongan kode diatas bila kita jalankan akan muncul seperti berikut:
<pre class="terminal">
$ php n-inheritance.php
Memanggil getConnection()...
Memanggil getConfig()...
Melakukan query select...
Melakukan query select by id - 10...
Melakukan query insert...
Melakukan query update...
Melakukan query delete...
Menghasilkan daily report 
Menghasilkan monly reportMemanggil getConnection()...
Memanggil getConfig()...
Melakukan query select...
Melakukan query select by id - 10...
Melakukan query insert...
Melakukan query update...
Melakukan query delete...
Melakukan authentikasi user 
Melakukan penggantian passwordMelakukan update password
</pre>
                </pre>
            </li>
            <li class="listboxitem" id="9">
                <h2>Polymorphism</h2>
                <pre>
<span class="indent"></span>Seperti yang telah jelaskan sebelumnya, polimorfisme adalah proses menciptakan beberapa objek dari kelas tertentu. Sebagai contoh, lihat contoh kasus berikut. Kita membutuhkan tiga kelas yaitu Emailer, ExtendedEmailer dan HtmlEmailer (anggap saja kelas ini telah dibuat dengan berbagai method didalamnya). Mari kita lihat kode berikut:
<pre class="code">
<span class="tagphpbuka"></span>
include("Emailer.php");
include("ExtendedEmailer.php");
include("HtmlEmailer.php");

$Emailer = new Emailer("hani@Bengak.com");
$ExtendedEmailer = new ExtendedEmailer();
$HtmlEmailer = new HtmlEmailer("hani@Bengak.com");

if ($ExtendedEmailer instanceof Emailer)
    echo "Extended Emailer is Derived from Emailer.<br/>";

if ($HtmlEmailer instanceof Emailer  )
    echo "HTML Emailer is also Derived from Emailer.<br/>";

// Tidak akan keluar output karena Emailer bukan instance HTMLEmailer
if ($Emailer instanceof HtmlEmailer )
    echo "Emailer is Derived from HTMLEmailer.<br/>";

// Tidak akan keluar output karena HTMLEmailer bukan instance Extended
if ($HtmlEmailer instanceof ExtendedEmailer  )
    echo "HTML Emailer is Derived from Emailer.<br/>";
<span class="tagphptutup"></span>
</pre>
Jika kamu menjalankan skrip di atas, kamu akan menemukan output berikut:
<pre class="terminal">
Extended Emailer is Derived from Emailer.
HTML Emailer is also Derived from Emailer.
</pre>
Itulah contoh penggunaan polymorphism, yaitu penggunaan method yang sama dengan fungsi yang berbeda-beda.
                </pre>
            </li>
            <li class="listboxitem" id="10">
                <h2>Override Method</h2>
                <pre>
<span class="indent"></span>Sesuai dengan namanya, overriding, kita dapat menimpa sebuah cara kerja suatu method di dalam class yang kita extend. Lalu ditimpa dengan logika yang kita butuhkan atau dimodifikasi. Namun salah satu ketentuanya adalah nama dan argumen yang dibutuhkan harus sama.

Mari kita perhatikan contoh kode berikut:
<pre class="code">
<span class="tagphpbuka"></span>

class Animal {

    public function speak() {
        echo "Hewan sedang bersuara!<br/>";
    }
}

class Dog extends Animal {

    public function speak() {
        echo "Guk guk guk guk!<br/>";
    }
}

$d = new Dog();
$d->speak();
</pre>
<span class="indent"></span>Pada kode diatas kita harus mengimplementasikan method speak() dari class Animal di-override di dalam class Dog. Bila kita jalankan akan muncul output seperti berikut:
<pre class="terminal">
$ php override-1.php
Guk guk guk guk!
</pre>
Bukannya keluar output yang sebelumnya, tapi output yang ditampilkan adalah output hasil override.

<strong>Menggunakan Method Induk Sebelum dilakukan Overriding</strong>
<span class="indent"></span>Untuk menggunakan fungsionalitas suatu method dari class induk, kita dapat membuat method lain dan memanggil method speak() dengan menggunakan tanda parent::speak() .

Mari kita perhatikan contoh kode berikut:
<pre class="code">
<span class="tagphpbuka"></span>

class Animal {

    public function speak() {
        echo "Hewan sedang bersuara!<br/>";
    }
}

class Dog extends Animal {

    public function speak() {
        echo "Guk guk guk guk!<br/>";
    }

    public function verboseSpeak()
    {
        parent::speak();
        $this->speak();
    }
}

$d = new Dog();
$d->speak();
$d->verboseSpeak();
</pre>
Sekarang mari kita jalankan dan lihat perbedaannya:
<pre class="terminal">
$ php override-2.php
Guk guk guk guk!
Hewan sedang bersuara!
Guk guk guk guk!
</pre>
Bila kita gunakan parent::speak() maka kita dapat memanggil fungsionalitas dari class induk sebelum di-override.
                </pre>
            </li>
            <li class="listboxitem" id="11">
                <h2>Interface</h2>
                <pre>
<span class="indent"></span>Interface adalah sebuah aturan dalam OOP dimana kita dapat membuat sebuah ketentuan yang harus selalu diimplementasikan dalam suatu kelas. Misal terdapat sebuah fungsionalitas dari CRUD data Posts/Artikel. Di dalamnya terdapat method select, insert, update, dan delete.

<span class="indent"></span>Bila salah satunya tidak diimplementasikan oleh programmer, maka saat runtime atau kompilasi akan terjadi error, karena programmer tersebut menyalahi aturan yang ditentukan dalam pembuatan suatu class

Mari kita perhatikan contoh kode berikut :
<pre class="code">
<span class="tagphpbuka"></span>

error_reporting(E_ALL);
ini_set('display_errors', 1);

// Interface pada sebuah CRUD
interface Crud {
    public function insert();
    public function update();
    public function select();
    public function delete();
}

// Buah class yang mengurusi data Posts, misal artikel.
class Posts implements Crud {
    public function insert() {
        echo "Call method insert ..\n";
    }

    public function update() {
        echo "Call method update ..\n";
    }

    public function select() {
        echo "Call method select ..\n";
    }
}

$posts = new Posts;
$posts->insert();
$posts->update();
$posts->select();
<span class="tagphptutup"></span>
</pre>
Pada kode diatas kita membuat sebuah interface Crud dan class Posts. Ceritanya Posts bertugas mengolah data tabel posts pada sebuah database. Bisa kita lihat, class Posts tidak membuat method delete. Kode diatas akan menghasilkan error seperti ini :
<pre class="terminal">
Fatal error: Class Posts contains 1 abstract method and must therefore be declared abstract or implement the remaining methods (Crud::delete) in /path/to/file.php on line 14
</pre>
Nah, disini kita belajar bahwa kita harus implementasi semua method pada interface setelah meng-implements. Mari kita perbaiki lagi kode jadi seperti ini :
<pre class="code">
<span class="tagphpbuka"></span>

error_reporting(E_ALL);
ini_set('display_errors', 1);

// Interface pada sebuah CRUD
interface Crud {
    public function insert();
    public function update();
    public function select();
    public function delete();
}

// Buah class yang mengurusi data Posts, misal artikel.
class Posts implements Crud {
    public function insert() {
        echo "Call method insert ..\n";
    }

    public function update() {
        echo "Call method update ..\n";
    }

    public function select() {
        echo "Call method select ..\n";
    }

    public function delete() {
        echo "Call method delete ..\n";
    }
}

$posts = new Posts;
$posts->insert();
$posts->update();
$posts->select();
$posts->delete();
?>
</pre>
Silahkan coba jalankan kode diatas dengan browser atau PHP CLI. Maka bisa ditebak, kode diatas akan lancar-lancar saja dan menghasilkan output seperti ini :
<pre class="terminal">
Call method insert .. 
Call method update .. 
Call method select .. 
Call method delete ..
</pre>

<strong>Multi Implementasi Interface pada Class di PHP</strong>
<span class="indent"></span>Bila contoh sebelumnya hanya menggunakan satu interface maka sekarang kita akan mencoba menggunakan beberapa interface pada suatu class. Masih dengan kasus yang sama. Mari kita perhatikan contoh kode berikut:
<pre class="code">
<span class="tagphpbuka"></span>

error_reporting(E_ALL);
ini_set('display_errors', 1);

// Interface pada sebuah CRUD
interface Crud {
    public function insert();
    public function update();
    public function select();
    public function delete();
}

// Interface Wipe, misalnya untuk fasilitas menghapus semua data, hanya contoh.
interface Wipe {
    public function wipe();
}

// Buat class yang mengurusi data Posts, misal artikel.
// Disini kita implement Crud dan Wipe, tinggal gabungkan dengan koma saja.
class Posts implements Crud, Wipe {
    public function insert() {
        echo "Call method insert ..\n";
    }

    public function update() {
        echo "Call method update ..\n";
    }

    public function select() {
        echo "Call method select ..\n";
    }

    public function delete() {
        echo "Call method delete ..\n";
    }

    // Wajib membuat method wipe, karena sudah di implement.
    public function wipe() {
        echo "Call method wipe ..\n";
    }
}

$posts = new Posts;
$posts->insert();
$posts->update();
$posts->select();
$posts->delete();
$posts->wipe();
<span class="tagphptutup"></span>
</pre>
Pada potongan kode diatas, kita hanya perlu memisahkan dengan tanda koma untuk menggunakan beberapa interface . Dan setiap method di dalam interface yang berbeda harus diimplementasikan semuanya di dalam class yang menggunakannya.

Hasil kode diatas adalah :
<pre class="terminal">
Call method insert .. 
Call method update .. 
Call method select .. 
Call method delete .. 
Call method wipe ..
</pre>
Bisa dipahami? mudah bukan :) .
                </pre>
            </li>
            <li class="listboxitem" id="12">
                <h2>Abstract Class</h2>
                <pre>
<span class="indent"></span>Berbeda dengan interface, selain memiliki method yang harus diimplementasikan, abstract pun berisi method yang dapat langsung digunakan tanpa diimplementasikan. Jadi kamu dapat membuat sebuah method yang memang tinggal digunakan tanpa harus dibuat oleh programmer. Selain itu abstract dapat berisi konstanta juga variabel dengan tingkat akses tertentu.

Mari kita perhatikan contoh kode berikut:
<pre class="code">
<span class="tagphpbuka"></span>

abstract class CoordinateAbstract {
    private $x = 10;
    private $y = 50;

    public function getX()
    {
        return $this->x;    
    }

    public function getY()
    {
        return $this->y;
    }

    abstract public function showMessage();
}

class MouseCoordinate extends CoordinateAbstract {

    public function showMessage()
    {
        echo "Ini adalah pesan dari Mouse Coordinate<span class="tagbr"></span>";
    }
}

class GPSCoordinate extends CoordinateAbstract {

    public function showMessage()
    {
        echo "Ini adalah pesan dari GPS Coordinate<span class="tagbr"></span>";
    }
}

$mc = new MouseCoordinate();
echo $mc->getX()."<span class="tagbr"></span>";
echo $mc->getY()."<span class="tagbr"></span>";
echo $mc->showMessage();

$gps = new GPSCoordinate();
echo $gps->getX()."<span class="tagbr"></span>";
echo $gps->getY()."<span class="tagbr"></span>";
echo $gps->showMessage();

// silahkan komen baris dibawah ini untuk menyembunyikan error

// $coord = new CoordinateAbstract();
// echo $coord->getX()."<span class="tagbr"></span>";
// echo $coord->getY()."<span class="tagbr"></span>";
// echo $coord->showMessage();
</pre>
Pada kode diatas kita harus mengimplementasikan method* yang ada di dalam CoordinateAbstract yaitu showMessage():
<pre class="terminal">
$ php abstract-1.php
10
50
Ini adalah pesan dari Mouse Coordinate
10
50
Ini adalah pesan dari GPS Coordinate
</pre>
Sekarang mari kita buka komentar baris kode yang dikomentari:
<pre class="code">
// silahkan komen baris dibawah ini untuk menyembunyikan error

$coord = new CoordinateAbstract();
echo $coord->getX()."<br/>";
echo $coord->getY()."<br/>";
echo $coord->showMessage();
</pre>
Dan bila kita jalankan lagi maka akan muncul keanehan seperti berikut:
<pre class="terminal">
10
50
Ini adalah pesan dari Mouse Coordinate
10
50
Ini adalah pesan dari GPS Coordinate

Fatal error: Uncaught Error: Cannot instantiate abstract class CoordinateAbstract in C:\xampp\htdocs\php-oop\source code\05\abstract-1.php:48 Stack trace: #0 {main} thrown in C:\xampp\htdocs\php-oop\source code\05\abstract-1.php on line 48
</pre>
<span class="indent"></span>Hal tersebut terjadi karena kita tidak melakukan instansiasi suatu abstract yang seharusnya kita implementasikan di class lain terlebih dahulu.

Contoh lain adalah bila kita tidak melakukan implementasi method showMessage(), maka akan terjadi error seperti berikut:
<pre class="code">
class MouseCoordinate extends CoordinateAbstract {

    // public function showMessage()
    // {
    //  echo "Ini adalah pesan dari Mouse Coordinate<br/>";
    // }
}
</pre>
Hasilnya adalah sebagai Berikut
<pre class="terminal">
Fatal error: Class MouseCoordinate contains 1 abstract method and must therefore be declared abstract or implement the remaining methods (CoordinateAbstract::showMessage) in C:\xampp\htdocs\php-oop\source code\05\abstract-1.php on line 26
</pre>

<strong>Implementasi Abstract dan Interface pada Suatu Class</strong>
<span class="indent"></span>Tidak hanya interface saja ataupun abstract saja, di dalam class PHP, dapat kita gunakan keduanya untuk membangun sebuah class yah tentu saja kita dapat menggunakan abstract dan class secara berdampingan.

Mari kita perhatikan contoh kode berikut:
<pre class="code">
<span class="tagphpbuka"></span>

abstract class MouseAbstract {
    private $weight = 10;

    public function leftClick()
    {
        echo "Klik kiri dijalankan<span class="tagbr"></span>";   
    }

    public function rightClick()
    {
        echo "Klik kanan dijalankan<span class="tagbr"></span>";
    }

    abstract public function scroll();
}

interface IGamingMouseFeature {

    public function upVolume();

    public function downVolume();

    public function connectToWireless();
}

class ClassicMouse extends MouseAbstract {

    public function scroll()
    {
        echo "Melakukan scroll di dalam classic mouse<span class="tagbr"></span>";
    }
}

class GamingMouse extends MouseAbstract implements IGamingMouseFeature {

    public function scroll()
    {
        echo "Melakukan scroll di dalam gaming mouse<span class="tagbr"></span>";
    }

    public function upVolume(){
        echo "Call upVolume()!<span class="tagbr"></span>";
    }

    public function downVolume(){
        echo "Call downVolume()!<span class="tagbr"></span>";
    }

    public function connectToWireless(){
        echo "Call connectToWireless()!<span class="tagbr"></span>";
    }
}

$m = new ClassicMouse();
echo $m->leftClick()."<span class="tagbr"></span>";
echo $m->rightClick()."<span class="tagbr"></span>";
echo $m->scroll();

$g = new GamingMouse();
echo $g->leftClick()."<span class="tagbr"></span>";
echo $g->rightClick()."<span class="tagbr"></span>";
echo $g->scroll();
echo $g->upVolume();
echo $g->downVolume();
echo $g->connectToWireless();
</pre>
Namun sayangnya kita hanya dapat meng-extend satu abstract sedangkan kita tetap dapat mengimplementasi banyak interface sesuai kebutuhan kita. Mari kita coba jalankan kode diatas:
<pre class="terminal">
$ php abstract-2.php
Klik kiri dijalankan

Klik kanan dijalankan

Melakukan scroll di dalam classic mouse
Klik kiri dijalankan

Klik kanan dijalankan

Melakukan scroll di dalam gaming mouse
Call upVolume()!
Call downVolume()!
Call connectToWireless()!
</pre>
                </pre>
            </li>
            <li class="listboxitem" id="13">
                <h2>Static Method dan Properties</h2>
                <pre>
<span class="indent"></span>Kata kunci static sangat penting dalam pemrograman berorientasi objek, method static dan properties memiliki peran penting dalam desain aplikasi dan juga dalam pola desain. Jadi apa itu static method dan properties?

<span class="indent"></span>Kamu telah melihat bahwa untuk mengakses method atau atribut dari sebuah kelas kamu harus membuat instance dengan menggunakan keword new. Jika tidak kamu tidak dapat mengakses kelas tersebut. namun, ada perbedaan static method dan properties. Kamu bisa mengakses static method atau properties secara langsung tanpa membuat instance dari kelas tersebut. Anggota statis seperti anggota global untuk kelas itu dan semua instance dari kelas itu. Juga, static properties bertahan pada keadaan terakhir dari apa yang ditugaskan, yang sangat berguna dalam beberapa kasus.
        
<span class="indent"></span>Kamu mungkin berpikir kenapa harus menggunakan static method? sebagian besar method static itu sama dengan method utility. Mereka menghasilkan tugas yang spesifik, atau mengembalikan objek yang spesifik (static properties dan method digunakan secara signifikan dalam design pattern, kita akan mempelajari design pattern nanti). Jadi untuk menyatakan objek baru setiap kali untuk objek itu mungkin dianggap menggunakan sumber daya yang banyak. Mari kita lihat contoh metode statis.
        
<span class="indent"></span>Pertimbangkan bahwa dalam aplikasi ini, kami menjaga dukungan untuk ketiga database, MySQL, PostgreSQL, dan SQLite. Sekarang kita perlu menggunakan satu driver tertentu pada suatu waktu. Untuk itu, kami merancang kelas DBManager, yang dapat membuat instantiate driver apa pun sesuai permintaan dan mengembalikannya kepada kami.
<pre class="code">
<span class="tagphpbuka"></span>
//class.dbmanager.php
class DBManager
{
    public static function getMySQLDriver()
    {
        //instantiate a new MySQL Driver object and return
    }

    public static function getPostgreSQLDriver()
    {
        //instantiate a new PostgreSQL Driver object and return
    }

    public static function getSQLiteDriver()
    {
        //instantiate a new MySQL Driver object and return
    }
}
?>
</pre>
Bagaimana kita menggunakan kelas itu? kamu bisa mengakses static property menggunakan :: operator dan jangan menggunakan operator ->. mari kita lihat contoh diabawah ini:
<pre class="code">
<span class="tagphpbuka"></span>

//test.dbmanager.php
include_once("class.dbmanager.php");
$dbdriver = DBManager::getMySQLDriver();
//now process db operation with this $dbdriver object
?>
</pre>
<span class="indent"></span>Perhatikan bahwa kita tidak membuat instance objek DBManager seperti $dbmanager = new DBManager(). melainkan, kita langsung mengakses salah satu metode menggunakan operator ::.

<span class="indent"></span>Jadi apa manfaatnya bagi kita? Kita hanya perlu objek driver, jadi tidak perlu membuat objek DBManager baru dan mengkomitnya ke memori selama skrip kita dieksekusi. Metode statis biasanya melakukan tugas tertentu dan menyelesaikannya.

<span class="indent"></span>Berikut ini beberapa hal penting yang perlu diperhatikan. kamu tidak dapat menggunakan $this pseudo object didalam static method. Karena kelas tidak digunakan, $this tidak terdapat didalam static method. Kamu sebaikya menggunakan self keyword.

Mari kita lihat contoh berikut ini. Ini menunjukkan bagaimana sebenarnya properti statis bekerja:
<pre class="code">
<span class="tagphpbuka"></span>

//class.statictester.php
class StaticTester
{
private static $id=0;

function __construct()
{
    self::$id +=1;
}

public static function checkIdFromStaticMehod()
{
    echo "Current Id From Static Method is ".self::$id."\n";
}

public function checkIdFromNonStaticMethod()
{
    echo "Current Id From Non Static Method is ".self::$id."\n";
}
}

$st1 = new StaticTester();
StaticTester::checkIdFromStaticMehod();
$st2 = new StaticTester();
$st1->checkIdFromNonStaticMethod(); //returns the val of $id as 2
$st1->checkIdFromStaticMehod();
$st2->checkIdFromNonStaticMethod();
$st3 = new StaticTester();
StaticTester::checkIdFromStaticMehod();
?>
</pre>
kamu akan melihat output seperti dibawah ini:
<pre class="terminal">
Current Id From Static Method is 1
Current Id From Non Static Method is 2
Current Id From Static Method is 2
Current Id From Non Static Method is 2
Current Id From Static Method is 3
</pre>
<span class="indent"></span>Setiap kali kita membuat instance baru, itu memengaruhi semua instance karena variabelnya dinyatakan statis. Menggunakan fasilitas khusus ini, design pattern khusus bernama "Singleton" bekerja dengan sempurna pada PHP.
                </pre>
            </li>
            <li class="listboxitem" id="14">
                <h2>Accesor Method</h2>
                <pre>
<span class="indent"></span>Metode Accessor merupakan metode yang semata-mata dikhususkan untuk mendapatkan dan mengatur nilai properti dari kelas apa pun. Ini adalah cara yang baik untuk mengakses properti kelas menggunakan metode accessor daripada langsung menetapkan atau mendapatkan nilainya. Meskipun accessor method sama dengan metode lainnya, ada beberapa cara/konvensi yang menuliskannya.

<span class="indent"></span>Ada dua jenis method accessor. yaitu getter dimana berfungsi sebgai mengembalikan nilai properti. yang kedua bernama setter yang berfungsi menyimpan atau mengeset nilai kedalam properti. mari kita lihat bagaimana method diatas digunakan :
<pre class="code">
<span class="tagphpbuka"></span>

class Student
{
private $name;
private $roll;
public function setName($name)
{
    $this->name= $name;
}
public function setRoll($roll)
{
    $this->roll =$roll;
}

public function getName()
{
    return $this->name;
}
public function getRoll()
{
    return $this->roll;
}
}

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Pada contoh di atas ada dua metode getter dan dua metode setter. terdapat konvensi dalam menulis metode aksesor. sebuah setter method harus dimulai dengan set dan nama properti setelahnya karakter awalnya harus dikapital (camle case). begitupun dengan method getter harus dimulai dengan get lalu diikuti dengan huruf kapital juga (camle case). Maksudnya jika kita kita memiliki properti bernama email, maka nama method tersebut harus getEmail dan setEmail.

<span class="indent"></span>sebenarnya kita dapat menggunakan nama apa saja, akan tetapi standart yang digunakan biasanya standart diatas. untuk memudahkan pembacaan ketika method ingin dipanggil atau digunakan.

<span class="indent"></span>jadi, kamu mungkin bertanya mengapa harus menggunakan ini, kan membuang-buang waktu dalam menulisnya. ketika kita dapat dengan mudah mengatur variabel-variabel ini sebagai publik. bukannya sama saja? tentu tidak, menggunakan accessor method kamu mendapatkan manfaat tambahan. kamu akan mendapat kontrol penuh saat mengatur dan mengambil nilai properti apapun. jika belum mengerti berikut studi kasusnya. ketika kam perlu memfilter input penggun dan mengaturnya menjadi properti. dalam hal ini, setter dapat membantu kamu untuk memfilter input sebelum mengaturnya agar berfungsi.

<span class="indent"></span>apakah artinya kita harus menulis 100 metode setter dan getter jika kelas kita memiliki 100 properti? ini pertanyaan menarik. PHP cukup baik dalam hal ini. bagaimana? mari kita lihat pada modul berikutnya dimana kita akan mempelajari magic method untuk setting dan getting nilai dari properti secara dynamically. method-method tersebyt akan mengurangi kebosanan anda secara drastis. tidak percaya? mari kita lihat di next materi, semoga bermanfaat :) .
                </pre>
            </li>
            <li class="listboxitem" id="15">
                <h2>Magic Method __set() dan __get()</h2>
                <pre>
<span class="indent"></span>Sebelumnya kita mendiskusikan tentang bagaimana cara menulis accessor method tapi jika properti yang ingin diimplementasikan banyak itu akan sangat menyusahkan. untuk menangani itu, kita bisa menggunakan magic method. cara ini disebut Property Overloading.

<span class="indent"></span>PHP memperkenalkan beberapa magic method pada class untuk mengurangi kebosanan OOP dalam beberapa kasus. Dua magic method tersebut diperkenalkan untuk mengatur dan mendapatkan nilai properti dinamis di kelas. Dua magic method ini dinamai __get() dan __set(). Mari kita lihat bagaimana menggunakannya:
<pre class="code">
<span class="tagphpbuka"></span>

// Class.student.php
class Student
{
    private $properties = array();

    function __get($property)
    {
        return $this->properties[$property];
    }

    function __set($property, $value)
    {
        $this->properties[$property]="AutoSet {$property} as: ".$value;
    }
}
?>
</pre>
Sekarang mari kita lihat bagaimana menggunakan kode diatas. Gunakan kelas di atas dengan skrip berikut:
<pre class="code">
<span class="tagphpbuka"></span>

$st = new Student();
$st->name = "Afif";
$st->roll=16;
echo $st->name."\n";
echo $st->roll;
?>
</pre>
<span class="indent"></span>Ketika kamu mengeksekusi kode sebelumnya, PHP segera mengenali bahwa tidak ada properti bernama name atau roll ada di kelas. Karena properti tersebut tidak ada, metode __set() dipanggil, yang kemudian menetapkan nilai ke properti kelas yang baru dibuat, yang memungkinkan kamu untuk melihat output berikut:
<pre class="terminal">
AutoSet name as: Afif
AutoSet roll as: 16
</pre>
Menarik bukan? menggunakan magic method kamu masih tetap memiliki kontrol penuh atas pengaturan dan pengembalian nilai properti dikelas.
                </pre>
            </li>
            <li class="listboxitem" id="16">
                <h2>Magic Method __call()</h2>
                <pre>
<span class="indent"></span>Seperti overloading, dan menggunakan method accessor, ada lagi magic method untuk melakukan pemanggulan method apapun pada kelas. Jika kamu masih belum terbiasa dengan method overloading, maka ini merupakan proses mengakses method apapun uang bahkan tidak terdapat pada kelas. Kedengarannya aneh, bukan? mari kita pahami lebih jauh.

<span class="indent"></span>Ada yang disebut magic method, yang akan membantu pemanggilan method pada kelas konteks di-PHP5. Nama method tersebut adalah method __call(). Ini memungkinkan kamu untuk memberikan tindakan atau mengembalikan nilai ketika metode yang tidak ditentukan dipanggil pada objek. Ini dapat digunakan untuk mensimulasikan metode overloading, atau bahkan untuk memberikan penanganan kesalahan yang halus ketika metode yang tidak ditentukan dipanggil pada objek. method __call memiliki dua argumen: nama metode dan array argumen yang diteruskan ke metode yang tidak ditentukan.

Sebagai contoh, lihat kode di bawah ini:
<pre class="code">
<span class="tagphpbuka"></span>

class Overloader
{
    function __call($method, $arguments)
    {
        echo "You called a method named {$method} with the following arguments <span class="tagbr"></span>";
        print_r($arguments);
        echo "<span class="tagbr"></span>";
    }
}

$ol = new Overloader();
$ol->access(2,3,4);
$ol->notAnyMethod("boo");

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Jika kamu memperhatikan kode di atas, maka kamu akan melihat bahwa tidak ada metode yang disebut access dan notAnyMethod. Karena itu, sepertinya akan mengeluarkan error. Namun, metode overloader masih membantu kamu memanggil metode yang tidak ada. Jika kamu menjalankan kode di atas, Anda akan mendapatkan output berikut.
<pre class="terminal">
You called a method named access with the following arguments 
Array
(
    [0] => 2
    [1] => 3
    [2] => 4
)

You called a method named notAnyMethod with the following arguments 
Array
(
    [0] => boo
)
</pre>
Itu berarti kamu akan mendapatkan semua argumen sebagai array. Ada banyak lagi magic method yang ada di PHP ini. Mari kita coba :) .
                </pre>
            </li>
            <li class="listboxitem" id="17">
                <h2>Method Chaining</h2>
                <pre>
<span class="indent"></span>Method chaining merupakan salah satu konsep yang ada dalam paradigma OOP untuk mengikat / merantai method. Disini kita dapat memanggil lebih dari satu method untuk satu kali operasi dengan mengolah object yang sama. Setiap method tersebut berperan mengubah nilai property dalam object tersebut dari satu bentuk ke bentuk lainnya. Oleh karena itu method tersebut sering disebut mutator. Konsep chaining ini sendiri sudah diimplementasikan dalam berbagai bahasa pemrograman yang mendukung OOP seperti Java, Python, Javascript, Ruby, dan PHP.

<span class="indent"></span>Manfaat dari penggunaan method chaining adalah membuat kode yang lebih enak dibaca. Coba perhatikan contoh kode berikut ini.
<pre class="code">
// Tanpa chaining
$object = new Class();
$object->method_satu();
$object->method_dua();
$object->method_tiga();

// Dengan chaining
$object = new Class();
$object->method_satu()->method_dua()->method_tiga();
</pre>
<span class="indent"></span>Nah, alih-alih memanggil method di beberapa baris kode, kita dapat membuat rantai method dalam satu baris kode. Dengan demikian kode akan terlihat lebih pendek.

<strong>Praktek Method Chaining</strong>
<span class="indent"></span>Mari kita coba membuat method chaining sederhana dengan menggunakan PHP. Kita akan membuat sebuah kelas bernama "StringMutator" yang berfungsi memanipulasi string. Dalam kelas tersebut, terdapat tiga method yang fungsinya sudah tidak asing lagi di telinga kita.
1. Bold, menebalkan kalimat
2. Italic, membuat kalimat menjadi cetak miring
3. Underscore, menambahkan garis bawah dalam kalimat

Struktur kodenya akan terlihat seperti ini :
<pre class="code">
class StringMutator {
    // Property untuk simpan nilai-nilai mutasi
    protected $word;

    public function __construct($word) {
        // Konstruktor
    }

    public function bold() {
    // Menebalkan kata
    }

    public function italic() {
    // Membuat cetak miring 
    }

    public function underscore() {
    // Menambahkan garis bawah
    }

    public function get() {
    // Mengambil nilai mutasi akhir
    }
}
</pre>
<span class="indent"></span>Bisa dilihat kita membutuhkan satu property bernama $word untuk menyimpan nilai mutasi. Di baris selanjutnya kita butuh sebuah magic method construct untuk mendefinisikan kata yang mau diolah ketika object diciptakan. Selanjutnya kita butuh 3 method (Bold, Italic, Underscore) untuk kemudian kita isi operasinya.

<span class="indent"></span>Oke, mari kita modifikasi kelas dan mengisi setiap method dengan operasi sebenarnya. Pada kelas ini kita akan menambahkan operasi bold, italic, dan underscore dengan cara memodifikasi string dengan menambahkan "html" saja, kurang lebih hasilnya seperti ini :
<pre class="code">
class StringMutator {

    protected $word;

    public function __construct($word) 
    {
        $this->word = $word;
    }

    public function bold() {
        $this->word = '<span class="tagboldbuka"></span>' . $this->word . '<span class="tagboldtutup"></span>';
        return $this;
    }

    public function italic() {
        $this->word = '<span class="tagitalicbuka"></span>' .$this->word . '<span class="tagitalictutup"></span>';
        return $this;
    }

    public function underscore() {
        $this->word = '<span class="tagunderlinebuka"></span>' . $this->word . '<span class="tagunderlinetutup"></span>';
        return $this;
    }

    public function get() {
        return $this->word;
    }
}
</pre>
<span class="indent"></span>Perhatikan method bold, italic, dan underscore yang kita buat. Setiap operasinya hanya meng-override nilai $word dan menyisipkan karakter html. Inilah salah satu contoh mutasi nilai. Perhatikan juga akhir dari setiap method, ada kode return ``$this;. Kode tersebut berfungsi mengembalikan object untuk kemudian dioperasikan lagi pada method selanjutnya. Dan terakhir method get() yang berfungsi untuk mengembalikan nilai final.

Mari kita coba class tersebut, kita akan mengolah string ini "Saya Belajar Method Chaining":
<pre class="code">
$word = 'Saya Belajar Method Chaining';

// Membuat object dan mendefinisikan string yang akan diolah 
$string_mutator = new StringMutator($word); 

// Contoh 1
// Operasi bold
$result = $string_mutator->bold()->get();
echo $result;

echo '<span class="taghr"></span>';

// Contoh 2
// Operasi bold + italic
$result = $string_mutator->bold()->italic()->get();
echo $result;
echo '<span class="taghr"></span>';

// Contoh 3
// Operasi bold + italic + underscore
$result = $string_mutator->bold()->italic()->underscore()->get();
echo $result;
</pre>
Untuk output nya bisa dicoba sendiri pada localhost masing-masing:

Demikian contoh sederhana dari penggunaan method chaining, Mudah bukan :) .
                </pre>
            </li>
            <li class="listboxitem" id="18">
                <h2>Namespace</h2>
                <pre>
<span class="indent"></span>Namespace atau bila kita artikan ke bahasa Indonesia artinya adalah ruang nama. Namun terasa aneh yah kedengarannya. Fitur ini merupakan fitur tingkat lanjut yang dimiliki oleh PHP 5.6+ dimana kita dapat menandai suatu file hanya bisa digunakan seisi kodenya melalui suatu alamat.

<span class="indent"></span>Alamat tersebut kita sebut dengan namespace, layaknya menulusuri suatu folder di dalam filesystem kita dapat menentukan kode kita ini berada di path mana. Hanya saja path yang digunakan merupakan virtual dan hanya dapat digunakan bila kode telah dijalankan oleh php interpreter.

<span class="indent"></span>Sebagai contoh buatlah sebuah File bernama index.php dan juga Folder bernama Bengak, didalam Folder Bengak tersebut buat 2 Folder yaitu Controller dan Model.

Mari kita perhatikan contoh kode berikut. Buat File Pertama adalah model.php didalam Folder Model:
<pre class="code">
<span class="tagphpbuka"></span>
    namespace Bengak\Model;

    class UserModel {

        public function selectAll()
        {
            echo "ini adalah function selectAll()!<br/>";
        }
    }
</pre>
Pada kode diatas kita tambahkan namespace Bengak\Model. Berikutnya File Kedua yaitu controller.php didalam Folder Controller:
<pre class="code">
<span class="tagphpbuka"></span>
    namespace Bengak\Controller;

    class HomeController {
        public function index()
        {
            echo "Ini adalah index!<br/>";
        }
    }
</pre>
Pada kode diatas kita gunakan namespace Bengak\Controller . Dan terakhir, kedua class sebelumnya akan dipanggil oleh index.php:
<pre class="code">
<span class="tagphpbuka"></span>
    require "controller.php";
    require "model.php";
    
    $controller = new \Bengak\Controller\HomeController();
    $controller->index();
    
    // buka komentar dibawah ini untuk melihat error
    
    // $model = new \Test\Model\UserModel();
    // $model->selectAll();
    
    $model = new \Bengak\Model\UserModel();
    $model->selectAll();
</pre>
Pada kode diatas, kita dapat memanggil suatu class bila file yang mengandung kode tersebut sudah di-require dan kita harus membubuhkan namespace dimana kode tersebut berada. Bila kita jalankan akan muncul output seperti berikut:
<pre class="terminal">
$ php index.php
Ini adalah index!
ini adalah function selectAll()!
</pre>
Nah bila kita membuka baris yang mengandung salah pemanggilan namespace. Maka akan muncul error seperti berikut:
<pre class="terminal">
$ php index.php
Ini adalah index!

Fatal error: Uncaught Error: Class 'Bengak\Model\UserModel' not found in C:\xampp\htdocs\php-oop\source code\08\index-1.php:11 Stack trace: #0 {main} thrown in C:\xampp\htdocs\php-oop\source code\08\index-1.php on line 11
</pre>
Hal ini disebabkan karena UserModel tidak terdapat di dalam namespace Test\Model melainkan berada di dalam namespace Bengak\Model.

<strong>Menyingkat Pemanggilan Class</strong>
<span class="indent"></span>Bahkan bila kamu harus berulang kali memanggil beberapa class di dalam suatu bagian di kode yang akan kamu kerjakan. Namespace tidak perlu disertakan terus menerus, cukup dipanggil sekali diatas bersama dengan class yang akan digunakan. Hasilnya kode kamu akan menjadi ringkas.

Mari kita perhatikan contoh kode index.php berikut:
<pre class="code">
<span class="tagphpbuka"></span>
    require "controller.php";
    require "model.php";

    use Bengak\Controller\HomeController;
    use Bengak\Model\UserModel;

    $controller = new HomeController();
    $controller->index();

    $model = new UserModel();
    $model->selectAll();
</pre>
Dengan cara ini, kamu cukup memanggil nama class-nya saja. Tentu saja bila kamu memanggil class tanpa mendeklarasikan namespace-nya terlebih dahulu menggunakan kata kunci use akan menyebabkan kode program error.

<strong>Namespace Alias</strong>
<span class="indent"></span>Bila namespace terlalu panjang, kamu dapat menyingkatnya dengan menggunakan as setelah nama namespace yang akan digunakan. Sehingga kamu tidak perlu terlalu repot untuk menulis segmen pertama dari namespace.

Mari kita perhatikan contoh kode index.php berikut:
<pre class="code">
<span class="tagphpbuka"></span>
    require "controller.php";
    require "model.php";
    
    use Bengak\Controller\HomeController as Controller;
    use Bengak as Test;
    
    $controller = new Controller();
    $controller->index();
    
    $model = new Test\Model\UserModel();
    $model->selectAll();
</pre>
Pada contoh diatas, tampak bahwa ketika memanggil HomeController menjadi Controller dan memanggil Bengak menjadi Test. Lebih mudah jika diringkas agar mudah juga untuk digunakan bukan ??
                </pre>
            </li>
            <li class="listboxitem" id="19">
                <h2>Autoloading Class</h2>
                <pre>
<span class="indent"></span>Sesuai dengan namanya, autoload, berarti kita dapat memanggil sebuah class secara otomatis tanpa harus menulisnya terlebih dahulu di bagian awal file. Kamu hanya perlu membuat beberapa baris di dalam spl_autoload_register(), maka kamu dapat memanggil class apapun.

Syaratnya antara lain:

1. Nama file dan class harus sama
2. Satu file hanya berisi satu class
3. Masih satu path(satu folder) dari file yang berisi kode tersebut

Mari kita perhatikan contoh kode berikut. File pertama adalah classA.php:
<pre class="code">
<span class="tagphpbuka"></span>

    class classA{
        public function showMessage()
        {
            echo "Ini adalah Class A\n";
        }
    }
</pre>
File berikutnya adalah classB.php:
<pre class="code">
<span class="tagphpbuka"></span>
    
    class classB{
        public function showMessage()
        {
            echo "Ini adalah Class B\n";
        }
    }
</pre>
Dan keduanya dapat dipanggil oleh index.php
<pre class="code">
<span class="tagphpbuka"></span>

    spl_autoload_register(function ($class_name) {
        include $class_name . '.php';
    });

    $clsA = new ClassA();
    $clsB = new ClassB();

    $clsA->showMessage();
    $clsB->showMessage();
</pre>
Bila kita jalankan maka hasilnya akan seperti berikut:
<pre class="terminal">
$ php index.php
Ini adalah Class A 
Ini adalah Class B
</pre>
<span class="indent"></span>Mengapa hal tersebut dapat terjadi? karena kita menggunakan spl_autoload_register() kita tidak perlu memanggil nama class sendiri dan cukup menggunakan baris tersebut untuk mengimpor class secara otomatis. Berapapun class yang dipanggil asalkan masih dalam satu path yang ditentukan di dalam spl_autoload_register(), class dapat kamu panggil.

<strong>Autoload Class di Folder Lain (Dalam suatu Folder)</strong>
<span class="indent"></span>Bila sebelumnya file index.php dan class - class berada dalam satu direktori, sekarang kita akan mencobanya berlainan direktori. Bagaimanakah jadinya?

Mari kita perhatikan contoh kode berikut. File pertama adalah bengak/Posts.php:
<pre class="code">
<span class="tagphpbuka"></span>

    class Posts {
        public function select() {
            echo "Ini adalah Class Posts, Method select dari Folder Bengak!\n";
        }
    }
</pre>
File berikutnya adalah bengak/PostsCategories.php:
<pre class="code">
<span class="tagphpbuka"></span>

    class PostCategories {
        public function select() {
            echo "Ini adalah Class PostCategories, Method select dari Folder Bengak!\n";
        }
    }
</pre>
Dan keduanya dapat dipanggil oleh index.php
<pre class="code">
<span class="tagphpbuka"></span>
    spl_autoload_register(function ($class_name) {
        include 'bengak/'.$class_name . '.php';
    });

    $p = new Posts();
    $pc = new PostCategories();

    $p->select();
    $pc->select();
</pre>
Bila kita jalankan maka hasilnya akan seperti berikut:
<pre class="terminal">
$ php index.php
Ini adalah Class Posts, Method select dari Folder Bengak! 
Ini adalah Class PostCategories, Method select dari Folder Bengak!
</pre>
                </pre>
            </li>
            <li class="listboxitem" id="20">
                <h2>Composer Singkat</h2>
                <pre>
<span class="indent"></span>Apakah kamu masih menyertakan library PHP yang dibuat orang lain secara manual ke dalam proyek PHP kamu? bila masih segera tinggalkan cara tersebut karena hal tersebut sudah tidak relevan di tahun 2018 ini.

<span class="indent"></span>Composer, yah suatu library yang akan mempermudah kamu menggunakan suatu library. Layaknya PIP di Python dan NPM di Node.js, kamu hanya perlu menyertakan library yang ingin kamu gunakan di dalam composer.json dan gunakan beberapa perintah untuk membantu kamu memasang library tersebut.

<span class="indent"></span>Bila kamu belum memilikinya silahkan pasang Composer di komputer atau laptop kamu dengan mengikuti cara install-nya disini: <a href="https://getcomposer.org/download/" target="_blank">https://getcomposer.org/download/</a>

<span class="indent"></span>Untuk Composer ini akan ada materi terpisah yang membahas Composer secara lebih detail. Ditunggu ya :) .
                </pre>
            </li>
            <li class="listboxitem" id="21">
                <h2>Eksistensi Class</h2>
                <pre> 
<span class="indent"></span>Jika kamu ingin mengetahui dan mengumpulkan informasi lebih banyak mengenai Class, Fungsi-fungsi ini dapat digunakan untuk itu. Fungsi ini dapat mengambil hampir semua informasi mengenai Class.

<strong>class_exists</strong>
<span class="indent"></span>Fungsi ini biasanya digunakan untuk mengetahui apakah class telah di definisikan. Berikut adalah keterangan mengenai fungsinya.

<b>Penggunaan</b>
<pre class="code">
class_exists ( string $class_name [, bool $autoload = TRUE ] ) : bool
</pre>
Fungsi ini memeriksa apakah class yang diberikan telah ditentukan atau tidak.

<b>Parameters</b>
1. class_name
class_name akan dicocokan dengan cara case-insensitive pada php.
2. autoload
Penggunaan ini merupakan optional untuk pengembalian nilai nantinya.

<b>Pengembalian Nilai</b>
Nilai akan berninal TRUE apabila class_name sudah di definisikan, dan nilai FALSE apabila belum.

<b>Contoh Penggunaan</b>
Contoh #1 class_exists()
<pre class="code">
<span class="tagphpbuka"></span>

    if (class_exists('MyClass')) {
        $myclass = new MyClass();
    }
<span class="tagphptutup"></span>
</pre>
Contoh #2 autoload
<pre class="code">
<span class="tagphpbuka"></span>

    function __autoload($class){
        include($class . '.php');
        
        // Pengecekan apabila class telah didefinisikan
        if (!class_exists($class, false)) {
            trigger_error("Class $class sudah ada Sehingga tidak di Load", E_USER_WARNING);
        }
    }

    if (class_exists('MyClass')) {
        $myclass = new MyClass();
    }

<span class="tagphptutup"></span>
</pre>
Cara terbaik untuk menggunakan fungsi class_exists () adalah dengan terlebih dahulu memeriksa apakah class sudah tersedia.

<strong>get_declared_classes</strong>
<span class="indent"></span>Fungsi ini biasanya digunakan untuk mengetahui nama class yang sudah didefiniskan.

<b>Penggunaan</b>
<pre class="code">
get_declared_classes ( void ) : array
</pre>
Fungsi ini mengembalikan array dengan nama class yang didefinisikan.

<b>Pengembalian Nilai</b>
Nilai yang dikembalikan dalam bentuk array. Array nya berisi nama-nama class yang telah di definisikan pada script saat ini.

<b>Contoh Penggunaan</b>
Contoh #1 get_declared_classes()
<pre class="code">
<span class="tagphpbuka"></span>
    print_r(get_declared_classes());
<span class="tagphptutup"></span>
</pre>

Contoh di atas akan menampilkan sesuatu yang mirip seperti berikut:
<pre class="terminal">
    Array
    (
        [0] => stdClass
        [1] => __PHP_Incomplete_Class
        [2] => Directory
        [3] => koneksi
    )
</pre>
Kamu akan melihat daftar kelas yang saat ini tersedia di layar.
                </pre>
            </li>
            <li class="listboxitem" id="22">
                <h2>Eksistensi Method dan Property</h2>
                <pre>
<span class="indent"></span>Jika kamu ingin mengetahui apakah property dan/atau methods tersedia di dalam class, Kamu dapat menggunakan fungsi method_exists () dan property_exists ().

<strong>method_exists</strong>
<span class="indent"></span>Fungsi ini biasanya digunakan untuk mengetahui apakah method telah di definisikan. Berikut adalah keterangan mengenai fungsinya.

<b>Penggunaan</b>
<pre class="code">
method_exists ( mixed $object , string $method_name ) : bool
</pre>
Fungsi ini memeriksa apakah methods class yang diberikan telah di definisikan pada object yang terkait.

<b>Parameters</b>
1. object
Contoh object atau nama class.
2. method_name
Nama method

<b>Pengembalian Nilai</b>
<span class="indent"></span>Nilai akan berninal TRUE apabila method_name sudah di definisikan untuk objek yang terkait, dan nilai FALSE apabila sebaliknya.

Contoh Penggunaan
<span class="indent"></span>Contoh #1 method_exists()
<pre class="code">
<span class="tagphpbuka"></span>
    $directory = new Directory('.');
    var_dump(method_exists($directory,'read'));
<span class="tagphptutup"></span>
</pre>
Contoh di atas akan menampilkan output seperti berikut:
<pre class="terminal">
bool(true)
</pre>
Kamu akan melihat nilai boolean yang saat ini tersedia di layar. Nilai itu akan menentukan apakah Method tersedia atau tidak.

<strong>property_exists()</strong>
<span class="indent"></span>Fungsi ini biasanya digunakan untuk mengetahui apakah object atau class memiliki property.

<b>Penggunaan</b>
<pre class="code">
property_exists ( mixed $class , string $property ) : bool
</pre>
Fungsi ini memeriksa apakah property yang diberikan ada di class yang ditentukan.

<b>Parameters</b>
1. class
Nama class atau object class yang akan diuji
2. property
Nama property

<b>Pengembalian Nilai</b>
<span class="indent"></span>Nilai akan berninal TRUE apabila property sudah di definisikan untuk objek yang terkait, dan nilai FALSE apabila sebaliknya atau NULL apabila terjadi error .

<b>Contoh Penggunaan</b>
<span class="indent"></span>Contoh #1 method_exists()
<pre class="code">
    <span class="tagphpbuka"></span>
    
    class myClass {
        public $mine;
        private $xpto;
        static protected $test;
    
        static function test() {
            var_dump(property_exists('myClass', 'xpto')); //true
        }
    }
    
    var_dump(property_exists('myClass', 'mine'));   //true
    var_dump(property_exists(new myClass, 'mine')); //true
    var_dump(property_exists('myClass', 'xpto'));   //true
    var_dump(property_exists('myClass', 'bar'));    //false
    var_dump(property_exists('myClass', 'test'));   //true,
    myClass::test();
    
    <span class="tagphptutup"></span>
</pre>
Untuk hasil outputnya bisa di lihat di komentar dimasing masing var_dump(), Semoga Bermanfaat :) .
                </pre>
            </li>
            <li class="listboxitem" id="23">
                <h2>Cek Nama dan Tipe Class</h2>
                <pre>
<span class="indent"></span>Jika kamu ingin mengetahui nama atau tipe class itu sendiri, Kamu dapat menggunakan fungsi get_class() atau is_a ().

<strong>get_class</strong>
<span class="indent"></span>Fungsi ini biasanya digunakan untuk mengetahui nama dari suatu class.

<b>Penggunaan</b>
<pre class="code">
get_class ([ object $object ] ) : string
</pre>
Fungsi ini digunakan untuk mendapat nama class.

<b>Parameters</b>
1. object
Contoh object atau nama class.

<b>Pengembalian Nilai</b>
<span class="indent"></span>Nilai akan bernilai string dan berisi nama class dari object terkait.

<b>Contoh Penggunaan</b>
Contoh #1 get_class()
<pre class="code">
<span class="tagphpbuka"></span>
    class foo {
        function name(){
            echo "Class Ini Bernama = " , get_class($this) , "\n";
        }
    }
    // create an object
    $bar = new foo();

    // external call
    echo "Nama Class = " , get_class($bar) , "\n";

    // internal call
    $bar->name();

<span class="tagphptutup"></span>
</pre>
Contoh di atas akan menampilkan sesuatu yang mirip seperti berikut:
<pre class="terminal">
Nama Class = foo
Class Ini Bernama = foo
</pre>

<strong>is_a()</strong>
<span class="indent"></span>Fungsi ini digunakan untuk memeriksa jenis class.

<b>Penggunaan</b>
<pre class="code">
is_a ( mixed $object , string $class_name [, bool $allow_string = FALSE ] ) : bool
</pre>

<b>Parameters</b>
1. object
Nama class atau object class yang akan diuji
2. class_name
Nama class
3. allow_string (Optional)
Memperbolehkan nama class String atau tidak (Default False)

<b>Pengembalian Nilai</b>
<span class="indent"></span>Nilai akan berninal TRUE apabila object merupakan instansiasi dari Class yang di definisikan. Bernilai FALSE apabila sebaliknya.

<b>Contoh Penggunaan</b>
<span class="indent"></span>Contoh #1 is_a(), pada Contoh kali ini menggunakan konsep inheritance untuk membuktikan bahwa object yang berasal dari instansiasi Child Class bersifat sama atau TRUE dengan Parent Classnya pada function is_a()
<pre class="code">
<span class="tagphpbuka"></span>

    class ParentClass{
    }

    class ChildClass extends ParentClass {
    }

    $cc = new ChildClass();
    if (is_a($cc,"ChildClass")){
        echo "Ini adalah class ChildClass <span class="tagbr"></span>";
    } 
    if (is_a($cc,"ParentClass")) {
        echo "Ini adalah class ParentClass <span class="tagbr"></span>";
    }

<span class="tagphptutup"></span>
</pre>
Kamu akan melihat output sebagai berikut:
<pre class="terminal">
Ini adalah class ChildClass
Ini adalah class ParentClass
</pre>
                </pre>
            </li>
            <li class="listboxitem" id="24">
                <h2>Clone Objek</h2>
                <pre>
<span class="indent"></span>Mengclone Objek adalah membuat salinan suatu objek. Salinan objek dibuat dengan menggunakan kata kunci clone.

<b>Penggunaan</b>
<pre class="code">
$objCloned = clone $objTarget;
</pre>
Fungsi yang dapat digunakan adalah clone.

<b>Contoh Penggunaan</b>
<span class="indent"></span>Pada contoh di bawah ini, objek disalin dengan menggunakan kata kunci clone php. Method clone PHP melakukan soft salinan. Setiap perubahan yang dilakukan pada objek yang disalin tidak akan mempengaruhi objek aslinya
Contoh #1 get_class()
<pre class="code">
<span class="tagphpbuka"></span>

    class Hewan{
        public $nama;
        public $kategori;
    }

    //Membuat instance dari kelas Hewan
    $objHewan = new Hewan();
    //Memasukan nilai
    $objHewan->nama = "Singa";
    $objHewan->kategori = "Hewan Liar";
    //Mengclone Object asli
    $objCloned = clone $objHewan;
    $objCloned->nama = "Serigala";
    $objCloned->kategori = "Hewan Liar";
    print_r($objHewan);
    print_r($objCloned);

<span class="tagphptutup"></span>
</pre>
Contoh di atas akan menampilkan output seperti berikut:
<pre class="terminal">
Hewan Object ( [nama] => Singa [kategori] => Hewan Liar ) Hewan Object ( [nama] => Serigala [kategori] => Hewan Liar )
</pre>

<strong>Kegunaan Clone di Real Case</strong>
<span class="indent"></span>Kata kunci clone memungkinkan kita untuk menyalin isi object ke suatu variable / object baru. Persis sama baik properti maupun methodnya. Dan masing masing object tidak akan saling mengganggu lagi operasionalnya / independen.

Berikut contoh mengcopy dengan assigment biasa, tanpa kata kunci clone :
<pre class="code">
<span class="tagphpbuka"></span>

    class Manusia {
        public $name;
    }
    
    $suami = new Manusia();
    $suami->name = 'Bambang'; // Isi nama suami
    
    $istri = $suami;
    $istri->name = 'Rani'; // Isi nama istri
    
    echo $istri->name . '<br>';
    echo $suami->name . '<br>';
</pre>
Diatas menceritakan kita punya class manusia, dan ingin membuat object suami dan istri. Jika tidak menggunakan clone output nya akan menjadi
<pre class="terminal">
Rani
Rani
</pre>
<span class="indent"></span>Pada kode tersebut kita mencoba copy object suami ke object baru bernama istri, lalu kita ubah nama nya menjadi nama istri. Tapi nama suami juga ikut berubah karena 2 object ini mengarah ke alamat memory yang sama.

Beda cerita jika menggunakan clone seperti ini :
<pre class="code">
    class Manusia {
        public $name;
    }
    
    $suami = new Manusia();
    $suami->name = 'Bambang';  // Isi nama suami
    
    $istri = clone $suami; // Cloning ..
    $istri->name = 'Rani';  // Isi nama istri
    
    echo $istri->name . '<span class="tagbr"></span>';
    echo $suami->name . '<span class="tagbr"></span>';
</pre>
Output program akan menjadi :
<pre class="terminal">
Rani
Bambang
</pre>
Sesuai dengan yang kita inginkan. Masing masing object tidak saling mengganggu propertinya ketika diubah.
                </pre>
            </li>
            <li class="listboxitem" id="25">
                <h2>Mengubah Array Menjadi Objek</h2>
                <pre>
<span class="indent"></span>Jika kita ingin mengkonversi array menjadi object dapat menggunakan json_encode dan json_decode. JSON adalah JavaScript Object Notation. PHP memberikan kita kemampuan untuk encode dan decode JSON.
                    
=> json_encode: digunakan untuk mengkonversi array ke json string
=> json_decode : digunakan untuk mengkonversi json string ke object

<b>Penggunaan</b>
Kita mempunyai array seperti berikut:                    
<pre class="code">
$array =[
    'hewan_liar' => [
        'Serigala',
        'Singa',
        'Macam',
        'Beruang',
        'Ular'
    ]
];
</pre>

<strong>Langkah 1 - Encode Array menjadi String</strong>
<span class="indent"></span>Kita dapat menggunakan fungsi json_encode sebagai berikut:
<pre class="code">
$object = json_encode($array);
</pre>
Output akan seperti berikut:
<pre class="terminal">
{"hewan_liar":["Serigala","Singa","Macam","Beruang","Ular"]}
</pre>                    
                    
<strong>Langkah 2 - Decode String menjadi Object</strong>
<span class="indent"></span>Sekarang kamu memiliki string json, kamu dapat menggunakan json_decode untuk mengkonversi dan memformat string ini menjadi sebuah objek. Mari kita coba itu dengan perintah berikut:
<pre class="code">
$object = json_decode(json_encode($array));
</pre>
Output:
<pre class="terminal">
stdClass Object ( [hewan_liar] => Array ( [0] => Serigala [1] => Singa [2] => Macam [3] => Beruang [4] => Ular ) )
</pre>
<span class="indent"></span>Satu hal yang perlu diperhatikan tentang json_decode adalah, ia mengubah string json ke objek kecuali Anda memberikan opsi kedua yang merupakan boolean yang mungkin TRUE atau FALSE.
                    
<b>Contoh Penggunaan JSON Encode dan Decode</b>
Akhirnya, kamu berhasil mengubah array menjadi sebuah objek. Kamu dapat menggunakannya dengan cara sebagai berikut:`
<pre class="code">
$array =[
    'hewan_liar' => [
        'Serigala',
        'Singa',
        'Macam',
        'Beruang',
        'Ular'
    ]
];

$object = json_decode(json_encode($array));

foreach ($object->hewan_liar as $hewan) {
    echo $hewan . "<span class="tagbr"></span>";
}
</pre>     
Contoh di atas akan menampilkan sesuatu yang mirip seperti berikut:
<pre class="terminal">
Serigala
Singa
Macam
Beruang
Ular
</pre>
<strong>Cara lain yang bisa digunakan</strong>
<span class="indent"></span>Menggunakan JSON encode dan decode untuk mengubah array ke objek dapat menghabiskan banyak sumber daya jika array lebih besar. Dengan cara ini, cara yang lebih baik untuk melemparkan array ke objek adalah menggunakan typecast objek. Sebagai contoh
<pre class="code">
$object = (object)$array;
</pre>
Output:
<pre class="terminal">
stdClass Object ( [hewan_liar] => Array ( [0] => Serigala [1] => Singa [2] => Macam [3] => Beruang [4] => Ular ) )
</pre>
Untuk penggunaan konversi kamu dapat memilih diantara dua pilihan diatas untuk merubah array menjadi object. Selamat Belajar :)
                </pre>
            </li>
            <li class="listboxitem" id="26">
                <h2>Design Pattern</h2>
                <pre>
<span class="indent"></span>Object Oriented Programming pada dasarnya digunakan untuk memudahkan proses pengembangan sebuah aplikasi serta dapat mengurangi waktu dalam mengembangkan sebuah aplikasi dengan mengurangi penggunaan kode. Jika direncanakan dan didesain dengan baik, OOP dapat meningkatkan peformansi dari program dengan skala yang besar.

<span class="indent"></span>Satu dari banyak cara ajaib dari pengurangan kode program adalam menggunakan pola Design Pattern yang diperkenalkan oleh Eric Gamma dan tiga temannya dalam buku Design Patterns pada 1972. Karena buku ditulis oleh empat penulis, buku tersebut dikenal dengan Gang of Four atau Goff. Pada buku yang sudah melegenda tersebut, Goff memperkenalkan beberapa pola untuk meminimalkan penggunakaan kode program serta memperkenalkan cara menulis program yang efektif. Pada Modul ini kita akan belajar Pola Design Pattern dalam PHP.
                </pre>
            </li>
            <li class="listboxitem" id="27">
                <h2>Strategy Pattern</h2>
                <pre>
<span class="indent"></span>Satu dari permasalahan umum yang sering kita temukan ketika melakukan pemrograman, adalah ketika dihadapkan dengan pilihan dalam cara membangun sebuah aplikasi. Strategy Pattern adalah pattern yang umum digunakan untuk membuat program dengan lebih mudah. Untuk memahami ini, mari kita membuat contoh program aplikasi notifikasi yang akan mengecek pilihan yang diberikan untuk user. User biasanya ingin diberitahu dengan banyak cara seperti, email, sms, atau fax. Program yang akan kita buat ini akan mengecek opsi yang tersedia untuk mengontak user dan membuat keputusan terhadap media yang akan digunakan. kasus ini akan mudah diselesaikan dengan menggunakan Strategy Pattern yang baik.
<img src="https://static.packt-cdn.com/products/9781847192561/graphics/2561_04_01.jpg" alt="Image Strategy Pattern">
<span class="indent"></span>Pada gambar pattern diatas, kita menggunakan tiga kelas yaitu SMSNotifier, EmailNotifier, dan FaxNotifier. Semua kelas ini mengimplementasikan interface Notifier, yang memiliki method bernama notify. Setiap dari tiga kelas ini mengimplementasikan method tersebut dengan kebutuhan kelas tersendiri.

Mari kita buat kelas interface terlebih dahulu.
<pre class="code">
<span class="tagphpbuka"></span>

    // Filename: Notifier.php
    interface Notifier{
        public function notify();
    }

<span class="tagphptutup"></span>
</pre>
Sekarang kita membuat method notify tersebut dimplementasikan dengan cara berbeda-beda sesuai dengan kebutuhan kelas yang mengimplementasikannya
<pre class="code">
<span class="tagphpbuka"></span>

    // Filename: EmailNotifier.php
    include_once("Notifier.php");
    
    class EmailNotifier implements Notifier {
        public function notify() {
            // Do something to notify the user by Email
            echo 'Notifikasi dengan menggunakan Email';
        }
    }

<span class="tagphptutup"></span>
</pre>
<pre class="code">
<span class="tagphpbuka"></span>

    // Filename: FaxNotifier.php
    include_once("Notifier.php");

    class FaxNotifier implements Notifier {
        public function notify() {
            // Do something to notify the user by Fax
            echo 'Notifikasi dengan menggunakan Fax';
        }
    }

<span class="tagphptutup"></span>
</pre>
<pre class="code">
<span class="tagphpbuka"></span>

    // Filename: SMSNotifier.php
    include_once("Notifier.php");

    class SMSNotifier implements Notifier {
        public function notify() {
            // Do something to notify the user by SMS
            echo 'Notifikasi dengan menggunakan SMS';
        }
    }

<span class="tagphptutup"></span>
</pre>
Lalu selanjutnya, mari kita buat class User untuk latihan, buat file dengan nama User.php. Berisi kode dibawah ini :
<pre class="code">
<span class="tagphpbuka"></span>
    include_once("EmailNotifier.php");
    include_once("FaxNotifier.php");
    include_once("SMSNotifier.php");

    class User {
        public function getNotified() {
            // Ganti ganti dengan nilai sms, email, fax
            return 'email'; 
        }
    }

    /**
        * Mari buat objek contoh bernama $user. Kita asumsikan dia punya method getNotified()
        * Dan method terebut akan mengembalikan nilai "sms" or "fax" or "email" kemudian perhatikan apa yang terjadi.
        */

    $user = new User();
    $notifier = $user->getNotified();

    switch ($notifier) {
        case "email":
            $objNotifier = new EmailNotifier();
            break;
        case "sms":
            $objNotifier = new SMSNotifier();
            break;
        case "fax":
            $objNotifier = new FaxNotifier();
        break;
    }

    $objNotifier->notify();
</pre>
Sangat sederhana bukan? oleh karena itu strategy pattern banyak digunakan oleh para programmer :) .
                </pre>
            </li>
            <li class="listboxitem" id="28">
                <h2>Factory Pattern</h2>
                <pre>

<strong>Konsep</strong>

<span class="indent"></span>Welcome back pada pembahasan design pattern. Pada tulisan kali ini kita akan mengupas pattern Factory. Mungkin kamu sering dengan istilah Factory. Factory ini jika kita terjemahkan ke dalam bahasa Indonesia adalah Pabrik.

<span class="indent"></span>Ya, memang pattern ini bersifat seperti pabrik. Tugasnya adalah membuat suatu object/benda. Pabrik sepatu menghasilkan sepatu, Recheese Factory memproduksi ayam goreng keju, pabrik tekstil memproduksi kain. Nah, dalam dunia OOP adalah menghasilkan object konkrit (instansiasi).

<span class="indent"></span>Mirip seperti pattern Singleton, tujuan dari pattern ini secara teknis adalah menyelesaikan masalah instansiasi. Namun lebih konseptual lagi adalah membuat kode kita menjadi lebih maintainable. Pattern Factory memungkinkan kita untuk hanya menyentuh sebuah interface saja untuk melakukan berbagai bisnis proses. Dibanding kita harus membuat objek konkrit, kita dapat membuat sebuah pabrik untuk menciptakan berbagai kebutuhan kita.

<span class="indent"></span>Bonus dari penggunaan pattern ini adalah menjadikan kode kita lebih extensible. Secara langsung menerapkan prinsip Open/Closed dari prinsipal SOLID. Dengan artian kita dapat menginjeksi sebuah proses bisnis baru pada kode kita, tanpa harus memodifikasi source code yang sudah berjalan.

Belum terbayang maksud dari konsep ini? bagaimana kalau kita langsung praktek, Ikuzooo...

<strong>Praktek Tanpa Factory</strong>
<span class="indent"></span>Ceritanya kamu saat ini sedang membuat modul payment untuk StartUp E-Commerce yang sedang naik daun. Pihak management perusahaan menginginkan platform tersebut menerima berbagai gerbang pambayaran seperti kartu kredit, GoPay, dan Dana. Lalu kamu eksekusi dengan membuat berbagai class/library untuk menangani masing-masing proses bisnis pembayaran.

Kurang lebih seperti ini :
<pre class="code">
<span class="tagphpbuka"></span>

/**
 * Bayangkan class class ini berada pada file terpisah.
 * Class real world tidak akan sesimple ini!
 * Saya gabungkan disini hanya untuk gambaran saja.
 */

class CreditCard {
    public function getStatus() {
        // Mengecek status koneksi ke server.
        echo "Checking Credit Card server .. \n";
    }

    public function sendIssue() {
        // Mengirim request untuk pembayaran.
        echo "Issue sent! \n";
    }
} 

class Dana {
    public function getStatus() {
        // Mengecek status koneksi ke server.
        echo "Checking Dana server .. \n";
    }

    public function sendIssue() {
        // Mengirim request untuk pembayaran.
        echo "Issue sent! \n";
    }
}

class GoPay {
    public function getStatus() {
        // Mengecek status koneksi ke server.
        echo "Checking GoPay server .. \n";
    }

    public function sendIssue() {
        // Mengirim request untuk pembayaran.
        echo "Issue sent! \n";
    }
}

// Ceritanya disini mengambil data pilihan pembayaran dari user.
// Dalam kasus yang lebih real bisa jadi datang dari POST/GET Request
// Dalam suatu file.
$option = 'Dana'; 
$payment = NULL;

if ($option == 'GoPay') {
    $payment = new GoPay;

    $payment->getStatus();
    $payment->sendIssue();

} else if ($option == 'Dana') {
    $payment = new Dana;

    $payment->getStatus();
    $payment->sendIssue();
} else {
    // Kode lanjutan.
}

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Bisa dilihat, masing-masing class memiliki fungsi menangani pembayaran sesuai dengan Brand-nya. Setiap class mempunyai method getStatus() dan sendIssue(). Ini hanyalah method khayalan saja, hanya untuk contoh. Method getStatus berfungsi Mengecek koneksi ke server pembayaran, sedangkan sendIssue berguna untuk mengirimkan request pembayaran.

<span class="indent"></span>Setelah pembuatan class, kita instansiasi objek nya sesuai dengan kebutuhan user. Pada kode tersebut misalnya saja yang dipilih adalah Dana. Terakhir, kita panggil masing-masing method untuk mengoperasikan pembayaran.

Output kode tersebut adalah :
<pre class="terminal">
Checking Dana server .. 
Issue sent! 
</pre>
<span class="indent"></span>Kode tersebut nampak baik-baik saja. Namun akan menjadi masalah ketika kita menginstansiasi objek konkrit tersebut di berbagai class. Suatu class akan tergabung sangat erat dengan objek tersebut (tightly coupled), sehingga sulit untuk di test.

<span class="indent"></span>Kemudian, jika ada perubahan perilaku pada masing-masing class tersebut, misalnya saja merubah nama method, maka kita harus merubah semua kode pada codebase.

<span class="indent"></span>Lebih parah lagi jika class/library ini sudah tersebar dan digunakan rekan satu tim di proyek besar, tentunya refactor besar-besaran kan terjadi jika ada perubahan. Mereka harus menyunting semua instansiasi yang sudah terlanjur digunakan.

<strong>Praktek Dengan Factory</strong>
<span class="indent"></span>Untuk menyelesaikan masalah ini, mari kita implementasi Factory. Pertama-tama kita harus membuat sebuah interface untuk kesepahaman antar class
<pre class="code">
interface PaymentInterface {
    public function getStatus();
    public function sendIssue();
}
</pre>
<span class="indent"></span>Disini setiap class wajib implementasi dua method pada interface tersebut. Pertama, getStatus dan yang kedua sendIssue. Method khayalan ini berguna untuk mengecek status dan mengirimkan request/issue pembayaran.

Kemudian, kita harus rombak masing-masing class, untuk menerapkan PaymentInterface :
<pre class="code">
class CreditCard implements PaymentInterface {
    public function getStatus() {
        // Mengecek status koneksi ke server.
        echo "Checking Credit Card server .. \n";
    }

    public function sendIssue() {
        // Mengirim request untuk pembayaran.
        echo "Issue sent! \n";
    }
} 

class Dana implements PaymentInterface {
    public function getStatus() {
        // Mengecek status koneksi ke server.
        echo "Checking Dana server .. \n";
    }

    public function sendIssue() {
        // Mengirim request untuk pembayaran.
        echo "Issue sent! \n";
    }
}

class GoPay implements PaymentInterface {
    public function getStatus() {
        // Mengecek status koneksi ke server.
        echo "Checking GoPay server .. \n";
    }

    public function sendIssue() {
        // Mengirim request untuk pembayaran.
        echo "Issue sent! \n";
    }
}
</pre>
<span class="indent"></span>Bisa dilihat, sekarang masing-masing class menerapkan dua buah method pada interface. Mari kita lanjutkan, sekarang buat sebuah class baru yang akan berperilaku sebagai pabrik :

<pre class="code">
class PaymentFactory {

    // Di method ini kita bikin konkrit class nya.
    public function getInstance($class) {
        return new $class;
    }
}
</pre>
<span class="indent"></span>Namingnya bebas sebenarnya. Namun sesuaikan saja dengan proses bisnis yang kita sedang kerjakan. Saya menggunakan nama PaymentFactory agar lebih natural dan mudah dipahami. Pada class tersebut hanya ada sebuah method bernama getInstance yang tugasnya membuat instansiasi sesuai dengan parameter yang dipassing.

<span class="indent"></span>Oke, mari kita lihat implementasinya pada outputnya seperti dibawah :
<pre class="terminal">
// Ceritanya disini mengambil data pilihan pembayaran dari user.
// Dalam kasus yang lebih real bisa jadi datang dari POST/GET Request
// Dalam suatu file.
$option = 'GoPay'; 

// Instansiasi Pabrik beserta parameter class yang mau diproduksi.
$PaymentFactory = new PaymentFactory;
$payment = $PaymentFactory->getInstance($option);
$payment->getStatus();
$payment->sendIssue();
</pre>
<span class="indent"></span>Pada kode tersebut, kita simulasikan pilihan user adalah GoPay. Kemudian, kita buat objek konkrit melalui PaymentFactory. Yang bertugas adalah method getInstance. Lalu kita jalankan method getStatus dan sendIssue untuk mengeksekusi proses bisnis real.

<span class="indent"></span>Jika kita gabungkan semuanya, maka kode lengkap terlihat seperti ini :
<pre class="code">
<span class="tagphpbuka"></span>

/**
 * Bayangkan class class ini berada pada file terpisah.
 * Class real world tidak akan sesimple ini!
 * Saya gabungkan disini hanya untuk gambaran saja.
 */

interface PaymentInterface {
    public function getStatus();
    public function sendIssue();
}

class CreditCard implements PaymentInterface {
    public function getStatus() {
        // Mengecek status koneksi ke server.
        echo "Checking Credit Card server .. \n";
    }

    public function sendIssue() {
        // Mengirim request untuk pembayaran.
        echo "Issue sent! \n";
    }
} 

class Dana implements PaymentInterface {
    public function getStatus() {
        // Mengecek status koneksi ke server.
        echo "Checking Dana server .. \n";
    }

    public function sendIssue() {
        // Mengirim request untuk pembayaran.
        echo "Issue sent! \n";
    }
}

class GoPay implements PaymentInterface {
    public function getStatus() {
        // Mengecek status koneksi ke server.
        echo "Checking GoPay server .. \n";
    }

    public function sendIssue() {
        // Mengirim request untuk pembayaran.
        echo "Issue sent! \n";
    }
}

/**
 * Pabrik yang akan membuat berbagai class.
 */
class PaymentFactory {

    // Di konstruktor kita bikin konkrit class nya.
    public function getInstance($class) {
        return new $class;
    }
}

// Ceritanya disini mengambil data pilihan pembayaran dari user.
// Dalam kasus yang lebih real bisa jadi datang dari POST/GET Request
// Dalam suatu file.
$option = 'GoPay'; 

// Instansiasi Pabrik beserta parameter class yang mau diproduksi.
$PaymentFactory = new PaymentFactory;
$payment = $PaymentFactory->getInstance($option);
$payment->getStatus();
$payment->sendIssue();
<span class="tagphptutup"></span>
</pre>
Output kode tersebut adalah :
<pre class="terminal">
Checking GoPay server .. 
Issue sent! 
</pre>
<span class="indent"></span>Sekarang, jika kita memerlukan berbagai Payment method kita cukup berhubungan dengan PaymentFactory. Bisa dilihat pada method getInstance kita membuat instansiasi class sesuai dengan class yang diinginkan. Class PaymentFactory dapat menyembunyikan kerumitan dibalik pabrikasi kelas konkrit.

<span class="indent"></span>Class ini lah yang akan disebar pada berbagai lini kode yang memerlukan instansiasi payment. Dengan cara ini kita bisa menjaga backward compability, ketika kita ingin patch library kita dengan fitur/class baru.

Referensi :
    <a target="_blank" href="https://refactoring.guru/design-patterns/factory-method">1. https://refactoring.guru/design-patterns/factory-method</a>
    <a target="_blank" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">2. https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle</a>
    <a target="_blank" href="https://en.wikipedia.org/wiki/SOLID">3. https://en.wikipedia.org/wiki/SOLID</a>
    <a target="_blank" href="https://www.atlanticbt.com/insights/net-online-payment-gateways-a-factory-pattern-model/">4. https://www.atlanticbt.com/insights/net-online-payment-gateways-a-factory-pattern-model/</a>
                </pre>
            </li>
            <li class="listboxitem" id="29">
                <h2>Abstract Factory</h2>
                <pre>
<span class="indent"></span>Abstract Factory hampir mirip dengan Factory, perbedaan satu-satunya adalah semua objek konkrit harus meng-extend abstract class yang diimplementasikannya. mungkin kamu bertanya apa keuntungan ketika kita menggunakan ini? Selama objek konkrit berasal dari abstract objek yang diketahui, membangun aplikasi akan lebih mudah karena semua berada pada kelas yang sama atau standart yang sama.

<span class="indent"></span>Mari kita lihat perbedaannya. Pertama kita membuat kelas abstract DBDriver dan kemudian meng-extend objek tersebut kedalam semua kelas yang mewarisi objek tersebut.
<pre class="code">
<span class="tagphpbuka"></span>
abstract class DBDriver
{
    public function connect();
    public function executeQuery();
    public function insert_id();
    public function setHost($host)
    {
        // Set db host
    }
    
    public function setDB($db)
    {
        // Set db name
    }
    public function setUserName($user)
    {
        // Set user name
    }
    public function setPassword($pwd)
    {
        // Set password
    }
}

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Berikut ini merupakan class MySQLManager yang diturunkan dari kelas abstract tersebut:
<pre class="code">
<span class="tagphpbuka"></span>

class MySQLManager extends DBDriver 
{
    public function connect()
    {
        // Implement own connection procedures
    }
    
    public function executeQuery()
    {
        // Execute mysql query and return result
    }
    
    public function insertId()
    {
        // Find the latest inserted id
    }
}

<span class="tagphptutup"></span>
</pre>
<img src="https://cdn-cdpl.sgp1.digitaloceanspaces.com/original/120478/1.jpg" alt="Image Abstract Factory">
<span class="indent"></span>Kurang lebih seperti itu contohnya. Sisanya sama seperti materi Factory Pattern pada materi sebelumnya. Manfaat utama ketika kita mendefinisikan semua fungsi yang diperlukan dalam satu tempat, adalah semua kelas yang mewarisi kelas abstract tersebut memiliki standart yang sama. Kita juga dapat mengengkapsulasi fungsi yang umum pada kelas abstract sehingga mengurangi redudansi fungsi yang sama.
                </pre>
            </li>
            <li class="listboxitem" id="30">
                <h2>Adapter Pattern</h2>
                <pre>
<span class="indent"></span>Kali ini kita akan melihat bagaimana sebuah adapter pattern dapat membantu kamu untuk menangani berbagai objek yang memerlukan sebuah method untuk menangani kasus general. Walaupun secara atribut class - class tersebut berbeda. Namun dengan adapter pattern ini, kita dapat menggunakan apa saja class-nya selama memenuhi syarat yang dibutuhkan oleh class adapter.

<span class="indent"></span>Misal kita memiliki beberapa class yang khusus untuk menangani berbagai dokumen elektronik. Meskipun mereka memiliki berbagai macam atribut yang berbeda. Mereka dapat ditangani oleh class adapter yang sama.

<span class="indent"></span>Mari kita lihat contoh berikut. Dimulai dengan file documents/entities/BaseDocument.php, yang memiliki maksud file BaseDocument.php berada di dalam direktori documents/entities. Jadi bila belum ada silahkan buat dahulu direktori tersebut karena kita akan menyimpan berbagai file di dalamnya.
<pre class="code">
<span class="tagphpbuka"></span>

class BaseDocument {

    protected $title = "";
    protected $author = "";
    protected $content = "";

    public function getTitle() 
    {
        return $this->title;
    }

    public function getAuthor() 
    {
        return $this->author;
    }

    public function getContent()
    {
        return $this->content;
    }
}
</pre>
<span class="indent"></span>Lalu seperti yang dijelaskan sebelumnya karena kita akan menggunakan beberapa jenis dokumen elektronik, mari kita telaah document/entities/Blog.php:
<pre class="code">
<span class="tagphpbuka"></span>

class Blog extends BaseDocument {

    private $url = "";

    public function __construct($title, $author, $content, $url) 
    {
        $this->title = $title;
        $this->author= $author;
        $this->content = $content;
        $this->url = $url;
    }

    public function getUrl()
    {
        return $this->url;
    }
}
</pre>
<span class="indent"></span>Sekarang mari kita telaah document/entities/Book.php:
<pre class="code">
<span class="tagphpbuka"></span>

class Book extends BaseDocument {

    public function __construct($title, $author, $content) {
        $this->title = $title;
        $this->author= $author;
        $this->content = $content;
    }
}
</pre>
<span class="indent"></span>Sekarang mari kita telaah document/entities/Paper.php:
<pre class="code">
<span class="tagphpbuka"></span>

class Paper extends BaseDocument {

    private $abstracts = "";

    public function __construct($title, $author, $content, $abstracts) 
    {
        $this->title = $title;
        $this->author= $author;
        $this->content = $content;
        $this->abstracts = $abstracts;
    }

    public function getAbstracts()
    {
        return $this->abstracts;
    }
}
</pre>
<span class="indent"></span>Apa yang dapat kamu tangkap dari class - class diatas? kita dapat melihat masing - masing dokumen memiliki atribut yang sama, yaitu $title, $author dan $content. Hanya beberapa class saja yang memiliki atribut berbeda seperti blog dan paper karena mereka memiliki field url dan abstracts.

<span class="indent"></span>Sekarang mari kita bedah di document/DocumentAdapter.php:
<pre class="code">
<span class="tagphpbuka"></span>

class DocumentAdapter{
    private $document;

    public function __construct($doc){
        $this->document = $doc;
    }

    public function createHeader(){
        $title = $this->document->getTitle();
        $author = $this->document->getAuthor();

        return "<h1></h1>".$title." created by ".$author.";
    }

    public function createPreview($length){
        return substr($this->document->getContent(), 0, $length);
    }
}
</pre>
<span class="indent"></span>Pada dua method diatas yaitu createHeader() dan createPreview() apapun jenis class-nya selama ada title, author, dan content dapat diambil, maka operasi pada kedua method tersebut dapat dijalankan.

<span class="indent"></span>Sekarang mari kita beralih ke file index.php yang berada di root folder, dan mari kita lihat bagaimana cara kerjanya.
<pre class="code">
<span class="tagphpbuka"></span>

spl_autoload_register(function ($class) {
    include "documents/entities/".$class.".php";
});

include "documents/DocumentAdapter.php";

$blog = new Blog("Hello World", "Ridwanbejo", 
"Lorem ipsum sit dolor amet!", "http://myblog.net/hello-world");

$documentAdapter = new DocumentAdapter($blog);
echo $documentAdapter->createHeader();
echo $documentAdapter->createPreview(50);

$book = new Book("Murder in Mesopotamia", "Agatha Christie", 
"Lorem ipsum sit dolor amet!. Lorem ipsum sit dolor amet!. 
Lorem ipsum sit dolor amet!. Lorem ipsum sit dolor amet!. 
Lorem ipsum sit dolor amet!. Lorem ipsum sit dolor amet!. 
Lorem ipsum sit dolor amet!. Lorem ipsum sit dolor amet!. 
Lorem ipsum sit dolor amet!. Lorem ipsum sit dolor amet!. 
Lorem ipsum sit dolor amet!. Lorem ipsum sit dolor amet!");

$documentAdapter = new DocumentAdapter($book);
echo $documentAdapter->createHeader();
echo $documentAdapter->createPreview(20);

$paper = new Paper("N-Tier Web Architecture for Resilient Business Infrastructure", 
"Kresna Galuh, Toni Haryanto, and Ahmad Oriza", "
Lorem ipsum sit dolor amet!. Lorem ipsum sit dolor amet!. Lorem ipsum sit dolor amet!. 
Lorem ipsum sit dolor amet!. Lorem ipsum sit dolor amet!. Lorem ipsum sit dolor amet!. 
Lorem ipsum sit dolor amet!. Lorem ipsum sit dolor amet!. Lorem ipsum sit dolor amet!. 
Lorem ipsum sit dolor amet!. Lorem ipsum sit dolor amet!. Lorem ipsum sit dolor amet!", 
"This is abstract!");

$documentAdapter = new DocumentAdapter($paper);
echo $documentAdapter->createHeader();
echo $documentAdapter->createPreview(30);
</pre>
<span class="indent"></span>Sekarang mari kita jalankan kode index.php:
<pre class="terminal">
C:\xampp\htdocs\php-oop\source code\11>php index.php
Hello World created by Ridwanbejo
Lorem ipsum sit dolor amet!
Murder in Mesopotamia created by Agatha Christie
Lorem ipsum sit dolo
N-Tier Web Architecture for Resilient Business Infrastructure created by Kresna Galuh, Toni Haryanto, and Ahmad Oriza
Lorem ipsum sit dolor amet!. L
</pre>
<span class="indent"></span>Apa yang terjadi? apapun class document yang dilewatkan akan digunakan oleh DocumentAdapter untuk melakukan operasi selama masih ada atribut yang dibutuhkan.
                </pre>
            </li>
            <li class="listboxitem" id="31">
                <h2>Singleton Pattern</h2>
                <pre>
<span class="indent"></span>Welcome Back pada pembahasan design pattern. Semoga kamu semakin semangat belajar materi ini. Kali ini kita akan belajar pattern Singleton. Pattern ini banyak diterapkan di berbagai framework, salah satunya adalah CodeIgniter4. Sebenarnya masalah yang ingin diselesaikan oleh pattern ini adalah instansiasi.

<span class="indent"></span>Mungkin kita secara sadar/tidak sering menginstansiasi object yang sama di berbagai tempat atau file. Ternyata ini buruk untuk management memory. Jika satu atau dua objek mungkin tidak terasa, bagaimana jika banyak?

<span class="indent"></span>Nah, disini Singleton pattern mencoba untuk menyelesaikan masalah tersebut. Pola penerapan Singleton sangat dikomendasikan untuk class/object yang hanya diperlukan satu kali objek dalam runtime/eksekusi program kita. Contohnya apa? koneksi database, logging, dst.

<span class="indent"></span>Yang perlu dicatat tidak semua objek atau class harus menerapkan Singleton. Dalam praktiknya namanya memprogram OOP kita pasti membutuhkan banyak instansiasi objek.

Supaya lebih paham mari kita lihat kode berikut ini :
<pre class="code">
<span class="tagphpbuka"></span>

// Tanpa menggunakan prinsip singleton.
class Database {
    public function __construct(){
        // Misal disini kode koneksi ke database.
        // Kalau di PHP misalnya saja mysqli_connect atau PDO connection.
    }

    public function query($sql){
        // Disini harusnya adalah sintaks PHP untuk melakukan query baik dengan mysqli_query atau PDO
        echo "Mengeksekusi \"{$sql}\" ..<span class="tagbr"></span>";
    }
}

// Menginstansiasi database.
$db = new Database;

// Melakukan query.
$db->query("SELECT * FROM users");
?>
</pre>
<span class="indent"></span>Pada kode tersebut kita membuat class Database, tidak ada yang spesial. Method __contruct bertugas mengkoneksikan program kita dengan DBMS. Sedangkan method query bertugas menjalankan sintaks SQL. Disitu hanya contoh, hanya mencetak string saja. Selanjutnya database kita instansiasi dan melakukan query.

<span class="indent"></span>Output kode tersebut adalah :
<pre class="terminal">
Mengeksekusi "SELECT * FROM users" ..
</pre>
<span class="indent"></span>Kode tersebut berjalan normal dan tidak ada masalah. Namun coba pikirkan jika program semakin kompleks, kamu harus meng-include kan file Database dimana-mana, pokoknya di semua lini kode yang membutuhkan koneksi database. Dalam satu kali runtime kamu tidak sadar beberapa kali menginstansiasi objek database, bukan hanya database, tapi juga objek lainnya yang sebenarnya hanya dibutuhkan satu kali instansiasi saja. Hal ini dapat menyebabkan kode kamu menjadi tidak efisien dan membuang-buang alokasi memory.

<span class="indent"></span>Ilustrasi Chaos :
<pre class="code">
// Menginstansiasi database di file A
$db = new Database;

// Menginstansiasi database di file B
$db = new Database;

// Menginstansiasi database di file C
$db = new Database;
</pre>
<span class="indent"></span>Bahkan di file yang sama ada beberapa instansiasi :)
<span class="indent"></span>Lalu bagaimana pattern Singleton untuk menyelesaikan masalah ini? Oke, saatnya kita rombak ke Singleton. Mari kita lihat kode berikut ini :
<pre class="code">
<span class="tagphpbuka"></span>

// Sudah menggunakan prinsip singleton.
class Database {

    // Bikin wadah untuk menampung objek.
    private static $instance = null;

    public function __construct(){
        // Misal disini kode koneksi ke database.
        // Kalau di PHP misalnya saja mysqli_connect atau PDO connection.
    }

    // Ini method pamungkas buat bikin objek, tidak perlu pakai new lagi.
    public static function getInstance()
    {
        // Self sama kegunaanya dengan $this, tapi khusus untuk static property.
        // Disini kita cek apakah sebelumnya instance sudah bikin apa belum untuk cegah double.
        // Kalau belum pernah dibikin kita new! kalau sudah kembalikan yang sudah ada.
        if (self::$instance == null) {
            self::$instance = new Database();
        } 

        // Kembalikan.
        return self::$instance;
    }

    // Method seperti biasanya.
    public function query($sql){
        echo "Mengeksekusi \"{$sql}\" ..<span class="tagbr"></span>";
    }
}

// Menginstansiasi database, via getInstance, tidak new lagi.
$db = Database::getInstance();

// Melakukan query.
$db->query("SELECT * FROM users");
</pre>
<span class="indent"></span>Outputnya sama saja :
<pre class="terminal">
Mengeksekusi "SELECT * FROM users" ..
</pre>
<span class="indent"></span>Tapi cara kerjanya sudah beda jauh. Nah, bisa dilihat pada kode, cuma ada penambahan property private untuk menyimpan hasil instansiasi. Juga method getInstance untuk melakukan instansasi dengan tambahan pengecekan. Pada kode tersebut ketika kita butuh objek Database, dapat dipanggil dengan cara :
<pre class="code">
// Tidak menggunakan $db = new Database;
$db = Database::getInstance();
</pre>
<span class="indent"></span>Dengan begini kita tidak akan pernah membuat instansiasi baru walaupun kode class ini di include dimana mana. Sudah pasti dalam runtime hanya akan menggunakan satu objek saja (satu alokasi memory). Kenapa bisa begini?

<span class="indent"></span>Cobalah disimak lagi kode berikut ini :
<pre class="code">
// Sudah ada belum?
if (self::$instance == null) {
    // Kalau blm ada bikin objek baru lalu assign ke property instance.
    self::$instance = new Database();
} 

// Kalau sudah ada kembalikan, tidak usah buat `new Database` lagi.
return self::$instance;
</pre>
<span class="indent"></span>Pengecekan pada method getInstance() akan menghindari double objek. Dia mengecek badan property pada class Database. Menarik bukan?

<span class="indent"></span>Lanjut, kita simulasi panggil beberapa kali dalam satu file, coba modifikasi kode jadi seperti ini :
<pre class="code">
// Kode sebelumnya
...

// Walaupun berkali kali dipanggil tidak akan pernah membuat alokasi memory baru.
$db1 = Database::getInstance();
$db2 = Database::getInstance();
$db3 = Database::getInstance();
$db4 = Database::getInstance();

// Mengecek dan buktikan apakah sama?
if ($db1 === $db2) {
    // Kalau tercetak sama, berarti proven.
    echo '<span class="tagbr"></span>Sama!<span class="tagbr"></span>';
}

// Melakukan query.
$db1->query("SELECT * FROM users");
$db2->query("SELECT * FROM users");
$db3->query("SELECT * FROM users");
$db4->query("SELECT * FROM users");
</pre>
<span class="indent"></span>Objek db1 sampai 4 pada kode diatas tidak akan pernah membuat objek baru. Dia akan memanggil objek yang sudah dibuat sebelumnya. Lalu disitu kita juga membuat kode perbandingan dengan === untuk memastikan objek tersebut sama saja.

<span class="indent"></span>Outputnya :
<pre class="terminal">
Sama!
Mengeksekusi "SELECT * FROM users" ..
Mengeksekusi "SELECT * FROM users" ..
Mengeksekusi "SELECT * FROM users" ..
Mengeksekusi "SELECT * FROM users" ..
</pre>
<span class="indent"></span>Begitulah kira-kira penggunaan dari pattern Singleton. Silahkan coba praktekkan lagi. Coba asah lagi kemampuan pattern Singleton pada materi ini. Bisa mencari kata kunci Singleton Pattern pada Google.

<span class="indent"></span>Sebagai informasi tambahan, pattern ini sebenarnya masih banyak diperdebatkan oleh berbagai pihak. Banyak orang yang tidak merekomendasikan pattern ini karena sulit untuk melakukan unit test pada program.

<span class="indent"></span>Namun nyatanya masih banyak yang menerapkan. Semua kembali ke kamu, lihat kondisi, jika bermanfaat pada studi kasus kamu, maka pakailah.

<strong>Ciri Khas Singleton Pattern</strong>
<span class="indent"></span>Pattern ini memungkinkan kita untuk bisa mengecek suatu class/object sudah pernah di instansiasi apa belum. Disini kita bisa manfaatkan Singleton untuk benar benar memastikan bahwa suatu class hanya di instansiasi 1 kali dalam ekosistem program kita.

<span class="indent"></span>Cuma memang terdapat beberapa perbedaan pendapat. Pattern ini juga terdapat kelemahan seperti :

<span class="indent"></span>Kita tidak bisa membuat class yang sama dalam sebuah program. Ini padahal di PHP sudah ada namespace untuk mencegah class colission. Jadi agak tidak berguna Singleton pattern. Justru diluar sana banyak peluang class yang identik dan sama karena library yang kita pakai macam-macam.

<span class="indent"></span>Yang menganut pattern seperti ini bisa lihat framework CodeIgniter 3. Kita gak akan pernah bisa membuat class yang sama karena bertabrakan.

<span class="indent"></span>Referensi : <a target="_blank" href="https://refactoring.guru/design-patterns/singleton">https://refactoring.guru/design-patterns/singleton</a>
                </pre>
            </li>
            <li class="listboxitem" id="32">
                <h2>Iterator Pattern</h2>
                <pre>
<strong>Pengertian Iterator</strong>
<span class="indent"></span>Iterator adalah salah satu bahasan yang menarik dalam dunia design pattern. Kalau kita terjemahkan ke bahasa Indonesia Iterator/Iteration adalah Iterasi atau pengulangan. Tapi nyatanya lebih dari sekedar mengurusi pengulangan. Iterator kurang lebih adalah sebuah konsep bagaimana cara kita mengolah suatu collection dengan teknik yang umumnya dipakai banyak programmer. Pattern iterator juga berguna sebagai abstraksi dari real data yang kita olah. Kita memanfaatkan teknik Iterator untuk mengolah berbagai data seperti XML, JSON, Array, dsb dengan sebuah interface baku.

<span class="indent"></span>Nah, selanjutnya apa sih collection? Collection tidak lebih adalah suatu data. Data siswa, data koordinat, data guru, data artikel, data transaksi dan sebagainya.

<span class="indent"></span>Dalam pemrograman sering sekali kita mengurusi suatu data. Bahkan sepertinya suatu aplikasi yang kita bikin tidak akan lepas dari yang namanya data. Dimulai dari development IoT sampai Web Development pasti isinya sedikit atau banyak adalah mengatur, mengakses, meyimpan, dan memanipulasi data. Dalam praktiknya data tersebut bisa saja kita looping, kita akses/traverse, kita ubah, dsb.

<span class="indent"></span>Untuk memahami Iterator Pattern sebaiknya teman-teman sudah ada pengetahuan dasar tentang OOP dan pernah membuat suatu aplikasi dengan PHP. Disini saya akan coba beri contoh kode seperti berikut :
<pre class="code">
<span class="tagphpbuka"></span>

// Sebuah koleksi data artikel.
$articles = [
    0 => [
        'title' => 'Judul 1',
        'content' => 'Konten 1'
    ],
    1 => [
        'title' => 'Judul 2',
        'content' => 'Konten 2'
    ],
    2 => [
        'title' => 'Judul 3',
        'content' => 'Konten 3'
    ]
];

print_r($articles);

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Kode diatas adalah contoh sebuah koleksi data bertipe array. Yang misalnya bisa datang dari Database, API, dan sebagainya. Kita langsung tulis saja untuk memperpendek kode.

<span class="indent"></span>Output kode diatas adalah :
<pre class="code">
Array(
    [0] => Array
        (
            [title] => Judul 1
            [content] => Konten 1
        )
    [1] => Array
        (
            [title] => Judul 2
            [content] => Konten 2
        )
    [2] => Array
        (
            [title] => Judul 3
            [content] => Konten 3
        )
)
</pre>
<span class="indent"></span>Sekilas memang tidak ada masalah dengan kode diatas. Dia hanya sebuah array yang kita tampilkan outputnya. Biasanya data array tersebut kita passing ke sebuah template bukan? misal ke sebuah view jika menganut MVC. Bisa jadi juga data tersebut diolah dulu seperti filtrasi, validasi dan sebagainya.

<span class="indent"></span>Nah untuk kasus sekarang, bagaimana jika sebelum kita passing ke view/template, kita ingin filtrasi, jika judul bernama "Judul 2" maka hapus datanya, hapus indexnya sehingga tidak tampil. Nah kita dapat melakukannya dengan bantuan Iterator dari PHP. Contohnya seperti berikut ini :
<pre class="code">
<span class="tagphpbuka"></span>

    // Sebuah koleksi data artikel.
    $articles = [
        0 => [
            'title' => 'Judul 1',
            'content' => 'Konten 1'
        ],
        1 => [
            'title' => 'Judul 2',
            'content' => 'Konten 2'
        ],
        2 => [
            'title' => 'Judul 3',
            'content' => 'Konten 3'
        ]
    ];
    
    // Mengkonversi data array menjadi object.
    $articles = new ArrayObject( $articles );
    
    // Mengimplementasikan Iterator pada array tersebut dengan method getIterator.
    $object = $articles->getIterator();
    
    // Maka sampai disini array kita sudah berubah menjadi object yang support iterator.
    // Sekarang kita coba looping ya dengan iterator method.
    while( $object->valid() )
    {   
        if ($object->current()['title'] == 'Judul 2') // Kalau ketemu Judul 2
            unset($articles[$object->key()]); // Hapus.
    
        $object->next();
    }
    
    // Kasih batas
    echo "\n";
    
    // Cetak ulang articles
    print_r($articles);

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Sekarang Judul 2 sudah tidak tampil, dan array kita sudah berubah menjadi object :
<pre class="code">
ArrayObject Object (
    [storage:ArrayObject:private] => Array
        (
            [0] => Array
                (
                    [title] => Judul 1
                    [content] => Konten 1
                )
            [2] => Array
                (
                    [title] => Judul 3
                    [content] => Konten 3
                )
        )
)
</pre>
<span class="indent"></span>Ini baru contoh sederhana, mungkin teman-teman bertanya-tanya, tanpa Iterator pun bisa kok menghapus index, dengan foreach array lalu unset. Sekali lagi ini hanyalah contoh. Banyak kemampuan lain jika kita menerapkan Iterator object pada collection kita. Seperti kita dapat memanipulasi data dengan mengganti current index dengan next atau prev method. Kurang lebih semuanya adalah untuk traverse (melintasi) suatu collection. Mari kita coba method lainnya :
<pre class="code">
<span class="tagphpbuka"></span>

    // Sebuah koleksi data artikel.
    $articles = [
        0 => [
            'title' => 'Judul 1',
            'content' => 'Konten 1'
        ],
        1 => [
            'title' => 'Judul 2',
            'content' => 'Konten 2'
        ],
        2 => [
            'title' => 'Judul 3',
            'content' => 'Konten 3'
        ]
    ];
    
    // Mengkonversi data array menjadi object.
    $articles = new ArrayObject( $articles );
    
    // Mengimplementasikan Iterator pada array tersebut dengan method getIterator.
    $object = $articles->getIterator();
    
    // Cetak index sekarang, akan mengakses index 0 yaitu Judul 1
    echo 'Index sekarang : ' . $object->current()['title'] . '<br/>';
    
    // Lalu kita coba majukan index
    $object->next();
    
    // Kita cetak lagi, harusnya sekarang jadi index 2 yaitu Judul 2
    echo 'Maju satu index : ' . $object->current()['title'] . '<br/>';
    
    // Reset ke 0
    $object->rewind();
    
    // Kita cetak lagi.
    echo 'Setelah di reset : ' . $object->current()['title'] . '<br/>';

<span class="tagphptutup"></span>
</pre>
Outputnya seperti ini :
<pre class="terminal">
Index sekarang : Judul 1
Maju satu index : Judul 2
Setelah di reset : Judul 1
</pre>
<span class="indent"></span>Bisa dipahami? suwaktu waktu pasti kita butuh method method traverse seperti ini, misalnya kita mengolah data yang lebih kompleks lagi seperti susunan array gambar.

<strong>Custom Iterator dengan Interface</strong>
<span class="indent"></span>Pada kode sebelumnya kita memanfaatkan class ArrayObject bawaan PHP untuk meng-enable Iterator. Simple sih, tapi tidak bisa kita custom. Nah, ada cara lain yang lebih custom untuk membuat pattern Iterator. Yaitu memanfaatkan Interface Iterator. Mari kita lihat kode berikut :
<pre class="code">
<span class="tagphpbuka"></span>

    /**
        * Pertama tama kita bikin dulu Class random dengan nama MyIterator. 
        * MyIterator ini yang akan menjadi class andalan kita untuk mengolah data. Nama class nya sebenarnya sih bebas ya. 
        * MyIterator ini kita build dengan implements Iterator.
        * 
        * Interface Iterator ini sudah bawaan mesin PHP, tidak harus kita define terlebih dahulu. Jika belum tahu Interface, 
        * coba baca dulu materi tentang Interface ya.
        * MyIterator ini harus menyediakan semua default interface Iterator seperti rewind, current, key, prev dst untuk kegunaan data traversing
        *  
        */
    
    class MyIterator implements Iterator {
        private $position = 0;
        private $data;
    
        public function __construct($data) {
            $this->position = 0;
    
            // Masukan param data ke property.
            $this->data = $data; 
        }
    
        public function rewind() {
            $this->position = 0;
        }
    
        public function current() {    
            return $this->data[$this->position];
        }
    
        public function key() {
            return $this->position;
        }
    
        public function next() {
            ++$this->position;
        }
    
        public function prev() {
            --$this->position;
        }
    
        public function valid() {
            return isset($this->data[$this->position]);
        }
    
        // Method tambahan .. tidak ada pada default iterator ArrayObject.
        public function remove($position) {
            unset($this->data[$position]);
        }
    }

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Jika kita lihat berbagai methodnya mirip dengan cara pertama. Karena memang sama-sama implement Iterator milik PHP. Tapi disini lebih kita custom lagi dengan menambahkan method tambahan bernama remove. Tugasnya adalah menghapus index collection yang kita inginkan. Mari kita lengkapi lagi kodenya jadi seperti ini :
<pre class="code">
<span class="tagphpbuka"></span>

    class MyIterator implements Iterator {
        private $position = 0;
        private $data;
    
        public function __construct($data) {
            $this->position = 0;
    
            // Masukan param data ke property.
            $this->data = $data; 
        }
    
        public function rewind() {
            $this->position = 0;
        }
    
        public function current() {    
            return $this->data[$this->position];
        }
    
        public function key() {
            return $this->position;
        }
    
        public function next() {
            ++$this->position;
        }
    
        public function prev() {
            --$this->position;
        }
    
        public function valid() {
            return isset($this->data[$this->position]);
        }
    
        // Method tambahan .. tidak ada pada default iterator ArrayObject.
        public function remove($position) {
            unset($this->data[$position]);
        }
    }

    // Kita punya data yang sama, mirip seperti cara pertama. Yaitu data articles.
    $articles = [
        0 => [
            'title' => 'Judul 1',
            'content' => 'Konten 1'
        ],
        1 => [
            'title' => 'Judul 2',
            'content' => 'Konten 2'
        ],
        2 => [
            'title' => 'Judul 3',
            'content' => 'Konten 3'
        ]
    ];

    // Sekarang mari kita instansiasi dengan construct data kedalam MyIterator. 
    // Sehingga nnt data array kita akan berubah menjadi object iterator.
    $object = new MyIterator($articles); // Passing articles.

    // Sekarang kita lakukan hal yang sama dengan cara pertama, yaitu traverse data.
    // Cetak index sekarang, akan mengakses index 0 yaitu Judul 1
    echo 'Index sekarang : ' . $object->current()['title'] . "\n";

    // Lalu kita coba majukan index
    $object->next();

    // Kita cetak lagi, harusnya sekarang jadi index 2 yaitu Judul 2
    echo 'Maju satu index : ' . $object->current()['title'] . "\n";

    // Reset ke 0
    $object->rewind();

    // Kita cetak lagi.
    echo 'Setelah di reset : ' . $object->current()['title'] . "\n";

    // Mari kita coba method remove, harusnya akan menghapus index 1
    $object->remove(1);

    // Cetak ulang
    print_r($object);

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Pada kode diatas kita mendefine class Iterator lalu menggunakannya. Dengan menginstansiasi object dengan construct data articles. Lalu kita panggil method traverse next, rewind. Serta mencoba custom method yang sudah kita buat yaitu remove.

<span class="indent"></span>Outputnya :
<pre class="terminal">
Index sekarang : Judul 1
Maju satu index : Judul 2
Setelah di reset : Judul 1
MyIterator Object
(
    [position:MyIterator:private] => 0
    [data:MyIterator:private] => Array
        (
            [0] => Array
                (
                    [title] => Judul 1
                    [content] => Konten 1
                )

            [2] => Array
                (
                    [title] => Judul 3
                    [content] => Konten 3
                )

        )

)
</pre>
<span class="indent"></span>Bisa dilihat sekarang articles membuang index ke 1 dan tersisa hanya 2 record saja.

<span class="indent"></span>Demikian materi tentang pattern Iterator. Tentunya materi ini baru secuil dari pembahasan Iterator. Teman-teman bisa mencoba baca sumber materi lain untuk melengkapi pemahaman tentang pattern ini. Semoga bermanfaat!
                </pre>
            </li>
            <li class="listboxitem" id="33">
                <h2>Observer Pattern</h2>
                <pre>
<span class="indent"></span>Selamat datang kembali di pembahasan design pattern. Dimana kita bisa membuat kode OOP yang lebih efektif dan maintanable, sesuai dengan tuntunan teori best practice orang-orang terdahulu.

<span class="indent"></span>Kali ini kita akan membahas pattern Observer. Pernahkah kamu menuliskan koding seperti ini :
<pre class="code">
<span class="tagphpbuka"></span>

    /**
     * Ceritanya ini adalah model User, yang mengurusi pendaftaran.
     * Kode ini hanya sample, sudah diusakan sedekat mungkin ke real world.
     * Disini flow bisnisnya, user ketika daftar akan dikirim notifikasi Sms dan Whatsapp.
     */
    
    // Class yang mengurusi Sms, bisa jadi adalah Library.
    class Sms {
        public function send() {
            echo "Mengirimkan sms! \n";
        }
    }
    
    // Class yang mengurusi whatsapp, bisa jadi adalah Library.
    class Whatsapp {
        public function send() {
            echo "Mengirimkan whatsapp! \n";
        }
    }
    
    // Class / model yang mengurusi user.
    class User {
        // Registrasi ..
        public function register() {
            echo "User berhasil didaftarkan! \n";
        }
    }
    
    $user = new User; 
    
    // Insert data.
    $user->register();
    
    // Lalu kirim Sms ke user.
    $Sms = new Sms;
    $Sms->send(); 
    
    // Lalu kirim Whatsapp ke user.
    $Whatsapp = new Whatsapp;
    $Whatsapp->send();

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Output dari kode diatas adalah :
<pre class="terminal">
User berhasil didaftarkan! 
Mengirimkan sms! 
Mengirimkan whatsapp!
</pre>                    
<span class="indent"></span>Terlintas memang tidak ada masalah, kodenya pun jalan lancar. Pada kode kita membuat tiga class. Yang pertama untuk menangani Sms, lalu library untuk menangani Whatsapp, dan yang terakhir User.
                    
<span class="indent"></span>Ketika user kita daftarkan kita memanggil proses bisnis lain yaitu mengirim pesan Sms lalu Whatsapp ke user. Kode ini mungkin mirip mirip ketika kamu membuat program OOP sendiri maupun di dalam framework MVC. Bayangkan saja jika kode tersebut ada di sebuah controller.
                    
<span class="indent"></span>Gaya pada kode tersebut akan bermasalah ketika kamu memiliki banyak tahap pada sebuah proses bisnis. Bukan hanya mengirim Sms dan Whatsapp, tapi juga men-trigger hal lain.
<pre class="terminal">
Registrasi -> Sms -> Whatsapp -> Proses C -> Proses D -> Proses E -> ...
</pre>
<span class="indent"></span>Bisa terbayang betapa gemuknya class kamu. Class disini bisa jadi controller, model, atau class pada PHP Native. Kelemahan lain dari kode tersebut adalah ketika kamu me-refactor class Whatsapp atau Sms menjadi lebih kompleks lagi. Jika method name berubah maka kode class User kamu akan broken.
                    
<span class="indent"></span>Nah, disini pattern Observer menawarkan solusi. Bagaimana kalau kita pasang pihak ketika bernama Observer. Biarkan observer class yang memanggil/notify class lain supaya mengerjakan apa yang kamu mau.
                    
<span class="indent"></span>Terdapat beberapa langkah untuk me-refactor tersebut. Mari kita coba satu per satu.
                    
<strong>Membuat Interface Observer</strong>
<span class="indent"></span>Membuat observer untuk membuat aturan baku pada objek yang ingin dipanggil.
<pre class="code">
interface Observer {
    // Mengatur agar semua yang ingin menjadi observer harus menggunakan method
    // Bernama send. Demi keseragaman dan kesepahaman.
    public function send();
}
</pre>
<span class="indent"></span>Lalu setelah ini, modifikasi sedikit kode pada masing-masing class yang menjadi trigger :
<pre class="code">
// Class yang mengurusi Sms, bisa jadi adalah Library.
class Sms implements Observer {
    public function send() {
        echo "Mengirimkan sms! \n";
    }
}

// Class yang mengurusi whatsapp, bisa jadi adalah Library.
class Whatsapp implements Observer {
    public function send() {
        echo "Mengirimkan whatsapp! \n";
    }
}
</pre>
<span class="indent"></span>Lanjut kita membuat sebuah class baru, yang akan menjadi observer dari proses bisnis program :
<pre class="code">
// Membuat class yang menerapkan observer.
class UserObserver {
    // Wadah untuk menampung observer yang didaftarkan.
    private $observers = [];

    public function attach($object)
    {
        // Masukan object dalam array.
        $this->observers[] = $object;

        // Pakai return $this, agar method bisa kita chaining.
        return $this;
    }

    // Method untuk jalankan semua observer.
    public function run()
    {   
        // Jalankan masing masing method run pada observer.
        // Kita pakai looping, observers isinya array.
        foreach ($this->observers as $observer)
        {
            // Panggil methodnya.
            $observer->send();
        }
    }
}
</pre>
<span class="indent"></span>Bisa diihat kita membuat dua buah method. Method pertama attach() untuk mendaftarkan service object yang akan dipanggil, method kedua run() untuk me-looping object yang sudah terdaftar, lalu menjalankannya.
                    
<span class="indent"></span>Terakhir, kita panggil jalankan semuanya :
<pre class="code">
$user = new User; 
                
// Insert data.
$user->register();

// Buat object UserObserver
$UserObserver = new UserObserver;

// Daftarkan object Sms, Whatsapp ..
$UserObserver->attach(new Sms)->attach(new Whatsapp);

// Jalankan.
$UserObserver->run();
</pre>
<span class="indent"></span>Semua kode jika digabungkan akan menjadi seperti ini :
<pre class="code">
<span class="tagphpbuka"></span>

/**
    * Ceritanya ini adalah model User, yang mengurusi pendaftaran.
    * Kode ini hanya sample, sudah diusakan sedekat mungkin ke real world.
    * Disini flow bisnisnya, user ketika daftar akan dikirim notifikasi Sms dan Whatsapp.
    */

interface Observer
{
    // Mengatur agar semua yang ingin menjadi observer harus menggunakan method
    // Bernama send. Demi keseragaman dan kesepahaman.
    public function send();
}

// Class yang mengurusi Sms, bisa jadi adalah Library.
class Sms implements Observer {
    public function send() {
        echo "Mengirimkan sms! \n";
    }
}

// Class yang mengurusi whatsapp, bisa jadi adalah Library.
class Whatsapp implements Observer {
    public function send() {
        echo "Mengirimkan whatsapp! \n";
    }
}

// Class / model yang mengurusi user.
class User {
    // Registrasi ..
    public function register() {
        echo "User berhasil didaftarkan! \n";
    }
}

// Membuat class yang menerapkan observer.
class UserObserver
{
    // Wadah untuk menampung observer yang didaftarkan.
    private $observers = [];

    public function attach($object)
    {
        // Masukan object dalam array.
        $this->observers[] = $object;

        // Pakai return $this, agar method bisa kita chaining.
        return $this;
    }

    // Method untuk jalankan semua observer.
    public function run()
    {   
        // Jalankan masing masing method run pada observer.
        // Kita pakai looping, observers isinya array.
        foreach ($this->observers as $observer)
        {
            // Panggil methodnya.
            $observer->send();
        }
    }
}

$user = new User; 

// Insert data.
$user->register();

// Bikin object UserObserver.
$UserObserver = new UserObserver;

// Daftarkan object Sms, Whatsapp ..
$UserObserver->attach(new Sms)->attach(new Whatsapp);

// Jalankan.
$UserObserver->run();
</pre>
<span class="indent"></span>Output kode tersebut sama saja dengan sebelumnya :
<pre class="terminal">
User berhasil didaftarkan! 
Mengirimkan sms! 
Mengirimkan whatsapp!
</pre>
<span class="indent"></span>Terlihat lebih maintainable bukan? sekarang jika kamu butuh proses tambahan, tinggal mendaftarkannya pada Observer. Biarkan observer yang menjalankan. Kode class User kamu juga sekarang lebih independen dan clean.
                </pre>
            </li>
            <li class="listboxitem" id="34">
                <h2>Proxy Pattern</h2>
                <pre>
<strong>Konsep</strong>
<span class="indent"></span>Selamat datang kembali pada pembahasan design pattern. Kali ini kita akan belajar tentang Proxy Pattern. Pastinya kalian sering mendengar istilah Proxy. Terutama untuk teman-teman yang sering menggunakan VPN. Cara kerjanya mirip. Untuk mengakses sebuah website kita harus melewati dulu sebuah "penengah", sehingga apa yang kita buka tidak terlacak oleh ISP, karena disangka hanya sedang mengakses website "penengah". Padahal kita sedang mengakses website real yang diblokir oleh ISP.

<span class="indent"></span>Jika kita hubungkan dengan dunia pemrograman, maka anggap saja "penengah" ini adalah sebuah class atau objek. Penengah ini disebut dengan proxy object. Disini alih-alih kita mengakses langsung real object, kita hanya mengakses Proxy. Tentunya karena adanya berbagai alasan.

<span class="indent"></span>Proxy pattern memiliki beberapa format penerapan diantaranya :

    - Remote Proxy
    - Virtual Proxy
    - Protection Proxy
    - Smart Reference
    
<span class="indent"></span>Namun disini kita akan coba pelajari hanya satu format, yaitu Smart Reference. Mudah-mudahan materi ini dapat terus diperbaharui.

<span class="indent"></span>Penasaran dengan cara kerja Proxy Pattern? mari kita praktek.

<strong>Praktek Tanpa Proxy</strong>
<span class="indent"></span>Pernahkah kamu menggunakan SDK/API atau apalah sebutannya, yang intinya itu adalah sebuah class. Kemudian kamu rasakan ketika memanggil sebuah method pada class tersebut terasa lambat sekali :
<pre class="code">
<span class="tagphpbuka"></span>

    /**
     * Misalnya ini adalah sebuah SDK/Class Twitter
     * Isi salah satu methodnya adalah getTweets
     * Misalnya saja class ini terdapat pada file terpisah.
     * Ini hanya untuk contoh ya :)
     */
    interface TwitterInterface {
        public function getTweets();
    }
    
    /**
     * Twitter API/SDK. 
     */
    class Twitter implements TwitterInterface {
    
        // Method ini berguna untuk mengambil public tweets dan ternyata response kadang terasa lama sekali.
        public function getTweets () {
            // Disini kode menjalankan REST API ke server Twitter untuk mengambil data Twitter.
            echo "Connecting to server .. \n";
            echo "Getting tweets .. \n";
            echo "Done .. \n";
    
            $outputSample = [
                [
                    'username' => '@budi',
                    'tweet' => 'Selamat pagi!',
                ],
                [
                    'username' => '@sarah',
                    'tweet' => 'Selamat malam!',
                ],
            ];
    
            return $outputSample;
        }
    }
    
    // Instansiasi.
    $Twitter = new Twitter;
    
    // Jalankan getTweets()
    print_r($Twitter->getTweets());

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Output :
<pre class="terminal">
Connecting to server .. 
Getting tweets .. 
Done .. 
Array
(
    [0] => Array
        (
            [username] => @budi
            [tweet] => Selamat pagi!
        )

    [1] => Array
        (
            [username] => @sarah
            [tweet] => Selamat malam!
        )

)
</pre>
<span class="indent"></span>Pada kode diatas ceritanya kita menggunakan library pihak ketiga. Kita include class ny pada core program, lalu membuat objek Twitter. Kemudian kita jalankan method getTweets() untuk mengambil public Tweet dari Twitter.

<span class="indent"></span>Pada praktiknya ternyata method getTweet() ini terasa tidak konsisten. Execution timenya berubah ubah, dan lebih parah lagi tidak menghasilkan output apapun, karena network latency yang tinggi. Hal ini mengakibatkan data response kadang kala kosong dan kita tidak bisa menampilkannya pada website/sistem.

<span class="indent"></span>Nah, disini Proxy Pattern hadir untuk kita. Kita bisa menyelesaikan masalah ini kita bisa menerapkan Smart Reference. Bagaimana sih caranya?

<strong>Praktek dengan Proxy</strong>
<span class="indent"></span>Caranya relatif mudah, kita cukup membuat sebuah class Proxy dengan menambahkan logika Cache di dalamnya. Mari kita lakukan step by stepnya.

<span class="indent"></span>Pertama-tama siapkan class yang berguna untuk caching terlebih dahulu. Misalnya disini saya contohkan dengan Redis. Sebenarnya kita juga bisa menggunakan sebuah table pada Database. Penerapan real bisa berbeda. Mari lihat kode berikut :
<pre class="code">
/**
* Redis Cache.
*/ 
class Redis {
    public function set($key, $value, $expiredTime) {
        echo "Saving data to cache .. \n";
    }

    public function get($key) {
        echo "Returning data from cache .. \n";
    }
}
</pre>
<span class="indent"></span>Kedua, baru kita membuat sebuah class Proxy :
<pre class="code">
/**
* Membuat Proxy.
*/
class TwitterProxy implements TwitterInterface{

    /*
    Kita menggunakan nama global, jangan langsung menggunakan nama konkrit objek
    Twitter kita ganti dengan property `api`. Redis kita ganti dengan property `cache`
    Hal ini agar class Proxy dapat lebih independen.
    Untuk memudahkan maintanance jika berganti objek konkrit.
    */
    protected $api;
    protected $cache;

    // Menambahkan konstruktor dengan inject objek Twitter dan Redis.
    public function __construct(Twitter $twitter, Redis $redis) {
        $this->api = $twitter; 
        $this->cache = $redis;
    }

    // Method getTweets kita modifikasi.
    public function getTweets () {

        // Cek dulu sudah ada data yang di cache?
        // Ceritanya key nya adalah "Tweets"
        if ($cached = $this->cache->get('Tweets')) {

            // Keluarkan output simulasi ..
            echo "Getting from cache .. \n";
            echo "Getting tweets .. \n";
            echo "Done .. \n";

            // Kembalikan cached, tidak usah ambil data lagi.
            return $cached;
        }

        // Kalau belum ada, baru ambil. 
        $result = $this->api->getTweets();

        // Jangan lupa masukan ke cache, lalu kita set expired timenya. Supaya bisa ambil data baru lagi.
        $this->cache->set('Tweets', $result, 3600);

        return $result;
    } 
}
</pre>
<span class="indent"></span>Penjelasannya sudah saya sisipkan pada setiap kode. Intinya kita membuat sebuah class Proxy yang mengkonsumsi objek Twitter dan Redis. Kita disitu membuat sebuah method getTweets() dengan kemampuan caching. Jika data pada cache ditemukan maka ambil saja dari cache. Jika tidak ada baru jalankan real object method. Dengan begitu, dalam beberapa rentang waktu kita tidak perlu takut koneksi gagal.

<span class="indent"></span>Sekarang mari kita lihat kode utuhnya. Disini saya coba masukan kode dalam satu file agar lebih sederhana. Harusnya pada praktek real, kode real object, proxy, dan cache terdapat pada file terpisah :
<pre class="code">
<span class="tagphpbuka"></span>

/**
    * Misalnya ini adalah sebuah SDK/Class Twitter
    * Isi salah satu methodnya adalah getTweets
    * Misalnya saja class ini terdapat pada file terpisah.
    */
interface TwitterInterface {
    public function getTweets();
}

/**
    * Twitter API/SDK. 
    */
class Twitter implements TwitterInterface {

    // Method ini berguna untuk mengambil public tweets dan ternyata response kadang terasa lama sekali.
    public function getTweets () {
        // Disini kode menjalankan REST API ke server Twitter untuk mengambil data Twitter.
        echo "Connecting to server .. \n";
        echo "Getting tweets .. \n";
        echo "Done .. \n";

        $outputSample = [
            [
                'username' => '@budi',
                'tweet' => 'Selamat pagi!',
            ],
            [
                'username' => '@sarah',
                'tweet' => 'Selamat malam!',
            ],
        ];

        return $outputSample;
    }
}

/**
    * Redis Cache.
    */ 
class Redis {
    public function set($key, $value, $expiredTime) {
        echo "Saving data to cache .. \n";
    }

    public function get($key) {
        echo "Returning data from cache .. \n";
    }
}

/**
    * Membuat Proxy.
    */
class TwitterProxy implements TwitterInterface{

    /*
    Kita menggunakan nama global, jangan langsung menggunakan nama konkrit objek
    Twitter kita ganti API, Redis kita ganti Cache
    Untuk memudahkan maintanance jika berganti objek konkrit.
    */
    protected $api;
    protected $cache;

    // Menambahkan konstruktor dengan inject objek Twitter dan Redis.
    public function __construct(Twitter $twitter, Redis $redis) {
        $this->api = $twitter; 
        $this->cache = $redis;
    }

    // Method getTweets kita modifikasi.
    public function getTweets () {

        // Cek dulu sudah ada data yang di cache?
        // Ceritanya key nya adalah "Tweets"
        if ($cached = $this->cache->get('Tweets')) {

            // Keluarkan output simulasi ..
            echo "Getting from cache .. \n";
            echo "Getting tweets .. \n";
            echo "Done .. \n";

            // Kembalikan cached, tidak usah ambil data lagi.
            return $cached;
        }

        // Kalau belum ada, baru ambil. 
        $result = $this->api->getTweets();

        // Jangan lupa masukan ke cache, lalu kita set expired timenya. Supaya bisa ambil data baru lagi.
        $this->cache->set('Tweets', $result, 3600);

        return $result;
    } 
}

/*
Cara lama tanpa Proxy
---------------------
$Twitter = new Twitter;
print_r($Twitter->getTweets());
*/

/*
Dengan Proxy
*/

// Konsumsi Proxy, bukan objek konkrit.
// Bangun objek dengan konstruktur dependency.
$Twitter = new TwitterProxy(new Twitter, new Redis);
print_r($Twitter->getTweets());

<span class="tagphptutup"></span> 
</pre>
<span class="indent"></span>Output :
<pre class="terminal">
Returning data from cache .. 
Connecting to server .. 
Getting tweets .. 
Done .. 
Saving data to cache .. 
Array
(
    [0] => Array
        (
            [username] => @budi
            [tweet] => Selamat pagi!
        )

    [1] => Array
        (
            [username] => @sarah
            [tweet] => Selamat malam!
        )

)
</pre>
<span class="indent"></span>Pada kode diatas kita tidak lagi menggunakan objek kontrit Twitter. Kita sudah menggunakan objek Proxy untuk menjalankan getTweets(). Disitu kita membuat juga menerapkan konstruktor Objek Twitter dan Caching, dengan sedikit bumbu konsep Dependency Injection.

<span class="indent"></span>Coba perhatikan lebih lanjut. Objek proxy dan konkrit menerapkan Interface yang sama. Hal ini merupakan aturan yang disarankan dalam konsep pattern ini. Hal ini bertujuan agar kedua objek tersebut bersifat Interchangeable, atau dapat saling menggantikan satu sama lain.

<span class="indent"></span>Perlu dicatat, ketika menerapkan proxy pattern, sebuah objek proxy diharuskan hanya fokus pada sebuah unit saja. Jangan sampai class proxy bertugas menggantikan berbagai class konkrit. Hal tersebut sudah menyalahi aturan proxy pattern. Dan tidak bisa disebut dengan proxy lagi.

<span class="indent"></span>Demikianlah materi Smart Reference, Proxy Pattern. Semoga dapat dipahami.

<span class="indent"></span>Referensi :

<span class="indent"></span>=> <a target="_blank" href="https://refactoring.guru/design-patterns/proxy">https://refactoring.guru/design-patterns/proxy</a>
<span class="indent"></span>=> <a target="_blank" href="http://ocramius.github.io/presentations/proxy-pattern-in-php/#/69">http://ocramius.github.io/presentations/proxy-pattern-in-php/#/69</a>
                </pre>
            </li>
            <li class="listboxitem" id="35">
                <h2>Decorator Pattern</h2>
                <pre>
<span class="indent"></span>Decorator Pattern adalah pendekatan penyelesaian masalah yang diperkenalkan oleh Gang Of Four dalam buku Design Pattern legendaris mereka. Menggunakan pola ini, kamu dapat menambahkan fungsionalitas tambahan ke dalam objek yang ada tanpa melakukan extend sebuah objek. Mungkin kamu bertanya apa manfaat dari menambahkan fungsionalitas tambahan tanpa melakukan pewarisan.

<span class="indent"></span>Tentu ada beberapa manfaatnya. Untuk Extend sebuah objek, seringkali kamu harus mengetahui banyak hal-hal di dalam kelas tersebut. Seringkali tidak mungkin untuk extend tanpa menulis ulang fungsionalitas yang ada. Jika kamu ingin menambahkan fungsionalitas yang sama kedalam beberapa tipe dari objek, akan lebih baik ketika menambahkan mereka menggunakan Decorator Pattern daripada meng-extend semuanya secara satu-persatu. Jika tidak, mungkin ini bisa membawa anda ke pemeliharaan aplikasi yang sangat menyeramkan.
<img src="https://cdn-cdpl.sgp1.digitaloceanspaces.com/original/120478/3.png" alt="Konsep Decorator Pattern">
<span class="indent"></span>Mari kita ke skenario yang umum, sebagai contoh, bayangkan ketika kamu membangun sebuah blog dan disitu ada fitur komentar. Data komentar ini memiliki objek tersendiri. Object komentar tersebut memiliki method yaitu getContent() dimana akan mengembalikan konten komentar.

<span class="indent"></span>Lalu ceritanya beberapa bulan kemudian setelah launching produk kamu membutuhkan fungsionalitas tambahan untuk memasukan Emoticon. Ceritanya inti badan program begitu komplek dan kamu tidak mau mengotak-atiknya. disini Decorator Pattern dapat menyelamatkan kamu.

<span class="indent"></span>Mari kita lihat kode berikut ini :
<pre class="code">
<span class="tagphpbuka"></span>
    // Sebuah class komentar. Yang memiliki properti / field name dan content.
    class Comment {
    
        private $name;
        private $content = 'Senyum manis :)';
    
        // Mempunyai getter message, baca lagi tentang getter pada materi setter/getter.
        public function getContent()
        {
            // Mengembalikan data pesan apa adanya.
            return $this->content;
        }
    }
    
    $comment = new Comment;
    echo $comment->getContent();
<span class="tagphptutup"></span>
</pre>
Kode diatas akan mengeluarkan output :
<pre class="terminal">
Senyum manis :)
</pre>
<span class="indent"></span>Terlihat tidak ada masalah pada class diatas. Tapi, sesuai scenario, ceritanya akan kita tambahkan fungsionalitas parser Emoticon. Mari kita buat class decorator nya tanpa melibatkan class Comment sama sekali.
<pre class="code">
<span class="tagphpbuka"></span>

    class EmoticonParser {
        private $content;
    
        // Membuat constuctor yang menerima object. Ini yang membuat independen. Nnt object yang membutuhkan Emoticon dipassing lewat sini.
        public function __construct($object)
        {
            $this->content = $object;
        }
    
        public function getContent()
        {
            // Nah disini class methodnya kita semacam override, dengan method yang sama kita tambahkan fungsionalitas Emoticon.
            // Panggil parseEmoticon.
            return $this->parseEmoticon($this->content->getContent());
        }
    
        private function parseEmoticon($content)
        {
            // Ini hanya contoh ya, harusnya parser Emoticon lebih rumit dari ini. Kita hanya string replace senyuman jadi gambar aja.
            return str_replace(':)', '<span class="taghtmlbuka"></span>img width="40" src="https://findicons.com/files/icons/360/emoticons/128/smile_1.png" /<span class="taghtmltutup"></span>', $content);
        }
    }

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Sudah jadi decorator / parser Emoticon nya. Bisa dilihat kita hanya membuat sebuah class yang dapat memanipulasi properti content. Disitu kita bikin method getContent yang isinya memparsing konten. Juga ditolong private method parseEmoticon yang secara teknis mengubah string jadi gambar.

<span class="indent"></span>Sekarang mari kita satukan semuanya. Kita terapkan decorator ke class Comment. Perhatikan kode lengkapnya :
<pre class="code">
<span class="tagphpbuka"></span>

// Sebuah class komentar. Yang memiliki properti / field name dan message.
class Comment {

    private $name;
    private $content = 'Senyum manis :)';

    // Mempunyai getter message, baca lagi tentang getter pada materi setter/getter.
    public function getContent()
    {
        // Mengembalikan data pesan apa adanya.
        return $this->content;
    }
}

class EmoticonParser
{
    private $content;

    // Membuat constuctor yang menerima object.
    public function __construct($object)
    {
        $this->content = $object;
    }

    // Nah disini class methodnya kita semacam override, dengan method yang sama kita tambahkan fungsionalitas Emoticon.
    public function getContent()
    {
        // Panggil parseEmoticon.
        return $this->parseEmoticon($this->content->getContent());
    }

    private function parseEmoticon($content)
    {
        // Ini hanya contoh ya, harusnya parser Emoticon lebih rumit dari ini. Kita hanya string replace senyuman jadi gambar aja.
        return str_replace(":)", "<span class="taghtmlbuka"></span>img width='40' src='https://findicons.com/files/icons/360/emoticons/128/smile_1.png' /<span class="taghtmltutup"></span>", $content);
    }
}

// Instansiasi Comment.
$comment = new Comment;
echo 'Sebelum parsing : ' . $comment->getContent();

echo '<span class="taghr"></span>';

// Kita ingin parsing, tinggal bikin instansiasi EmoticonParse lalu masukan object Comment jadi parameter.
$EmoticonParser = new EmoticonParser($comment);
echo 'Setelah parsing : ' . $EmoticonParser->getContent(); // Method yang dipanggil sama :) getContent

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Pada kode diatas kita menginstansiasi class Comment dan mencoba mengeluarkan output content. Kemudian kita bikin lagi object EmoticonParser yang mempassing objek Comment. Setelah itu kita panggil fungsionalitas decorator nya yaitu getContent. Outputnya akan terlihat seperti ini :
<img src="https://cdn-cdpl.sgp1.digitaloceanspaces.com/original/120478/32.png" alt="Output Decorator Pattern">
<span class="indent"></span>Begitulah cara menambahkan fungsionalitas tambahan kedalam objek yang sudah ada tanpa menyentuh program utama. Kamu melihat dimana EmoticonParser dapat menerima objek apapun. Silahkan coba kode diatas pada komputer kamu, jika berhasil maka selamat! Kamu sudah berhasil menerapkan Decorator Pattern
                </pre>
            </li>
            <li class="listboxitem" id="36">
                <h2>Active Record Pattern</h2>
                <pre>
<strong>Konsep</strong>
<span class="indent"></span>Selamat datang kembali pada pembahasan design pattern. Kali ini kita akan membahas <b>Active Record Pattern</b>. Mari kita pahami dulu pengertian pattern ini. Dikutip dari Wikipedia, Active Record Pattern adalah sebuah pola arsitektur yang menerapkan pendekatan objek dalam mengakses database. Teori Active Record berasal dari buku penting ilmu komputer berjudul <b>Patterns of Enterprise Application Architecture</b> yang ditulis oleh programmer veteran, Martin Fowler dan kawan-kawan.
<img src="https://www.martinfowler.com/eaaCatalog/activeRecordSketch.gif" alt="Image Active Record Pattern">
<span class="indent"></span>Dalam praktiknya, sebuah tabel pada database akan dianggap sebagai objek atau class. Cara mengakses dan memanipulasi data tidak lagi dengan raw SQL, melainkan dengan pendekatan objek. Field pada table dianggap sebagai property, dan aksi manipulasi dibungkus oleh method. Sebuah objek akan terikat penuh pada sebuah row/record table.
                    
<span class="indent"></span>Kelebihan jika kita menggunakan pattern ini :
<ul class="list">
    <li>Tidak perlu paham SQL, kita tidak akan berinteraksi lagi dengan sintaks SQL. Kita total berinteraksi pada object.</li>
    <li>Tidak perlu paham SQL, kita tidak akan berinteraksi lagi dengan sintaks SQL. Kita total berinteraksi pada object.</li>
    <li>Multi Database, biasanya library Active Record juga menambahkan driver. Sekali tulis kode sudah support ke berbagai database.</li>
    <li>Full OOP, menulis kode manipulasi dengan pendekatan object, lebih terasa menyatu dengan dunia OOP.</li>
    <li>Simple, kita tidak akan lg bertemu dengan SQL sintaks seperti select, join, dll. Cukup dengan object class saja.</li>
</ul>                    
<span class="indent"></span>Tentunya dibalik beberapa kelebihan Active Record juga terdapat beberapa kekurangan. Banyak juga yang tidak suka dengan pola ini. Dan lebih memilih menulis kode akses/manipulasi dengan SQL.
                    
<span class="indent"></span>Jika belum terbayang tidak apa-apa, kita akan praktekan pada bagian praktek pada materi ini. Jika sudah tidak sabar silahkan skip langsung pada materi praktek. Perlu diketahui, pada materi kali ini kita tidak akan membuat sebuah class Active Record sendiri. Tapi hanya akan mencicipi Active Record library pada pemrograman PHP Native. Mungkin di lain waktu kita kan coba membuatnya sendiri.
                    
<strong>Fakta Industri</strong>
<span class="indent"></span>Jika berbicara Active Record, pasti akan menyenggol istilah baru yaitu ORM (Object Relational Mapping). Bagi teman-teman yang sudah terbiasa dengan Framework PHP, pasti familiar dengan ORM. Benda apa sih ORM ini? Sebenarnya ORM ini adalah salah satu konsep object mapping yang menerapkan Active Record. Banyak sekali programmer yang sudah membuat library ORM ini. Berikut ini daftar ORM yang menerapkan Active Record pattern :
<ul class="list">
    <li><a target="_blank" href="https://www.redbeanphp.com/">RedBean ORM</a></li>
    <li><a target="_blank" href="https://laravel.com/docs/7.x/eloquent">Eloquent ORM (User Laravel pasti Familiar)</a></li>
    <li><a target="_blank" href="https://www.doctrine-project.org/projects/orm.html">Doctrine ORM</a></li>
    <li><a target="_blank" href="http://propelorm.org/">Propel</a></li>
    <li><a target="_blank" href="https://phpixie.com/components/orm.html">PHPixie ORM</a></li>
    <li><a target="_blank" href="https://github.com/toopay/gas-orm">Gas ORM (Buatan senior programmer Indonesia)</a></li>
    <li><a target="_blank" href="https://guides.rubyonrails.org/active_record_basics.html">Rails ActiveRecord</a></li>
    <li><a target="_blank" href="https://phpixie.com/components/database.html">PHPixie DB</a></li>
    <li>Dan masih banyak lagi.</li>
</ul>

<strong>Praktek</strong>
<span class="indent"></span>Mari kita mencicip Active Record Pattern dengan ORM. Kita akan mencoba library yang paling nyentrik diantara semua yang saya sebutkan tadi. Yaitu Redbean ORM. Kelebihan Redbean ORM dibanding ORM lain adalah otomasi building schema, dan penggunaan yang sangat mudah. Cocok untuk kalian yang baru masuk ke dunia ORM.
                    
<b>Install Composer</b>
<span class="indent"></span>Pertama-tama kamu harus install composer. Kita akan install Readbean ORM diatas composer. Bagi yang belum paham composer bisa membaca dulu tentang composer <a href="#">Disini (Sementara Coming Soon)</a> <!-- https://belajarphp.net/cara-install-dan-menggunakan-composer/ -->
                    
<span class="indent"></span>Sudah menginstall composer?, Untuk memastikan composer sudah terpasang atau belum, silahkan ketik perintah :
<pre class="code">
composer --help
</pre>                    
<span class="indent"></span>Harusnya akan keluar dokumentasi cara penggunaan composer.
                    
<b>Install Redbean</b>
<span class="indent"></span>Baiklah, jika composer sudah berjalan dengan baik, kita lanjutkan untuk memasang Redbean ORM. Buatlah sebuah folder bernama latihan-orm, lalu masuk di direktori tersebut dan jalankan perintah berikut ini :
<pre class="code">
composer require gabordemooij/redbean
</pre>
<span class="indent"></span>Tunggu sampai proses instalasi selesai. Setelah itu coba cek, sekarang folder latihan-orm berisi file file composer seperti composer.json, composer.lock, juga folder vendor.
                    
<span class="indent"></span>Pada folder latihan buatlah file bernama index.php dengan berisi kode berikut ini :
<pre class="code">
<span class="tagphpbuka"></span>
                
ini_set('display_errors', 1); 
ini_set('display_startup_errors', 1); 
error_reporting(E_ALL); 

require 'vendor/autoload.php';

use \RedBeanPHP\R as R;

R::setup( 'mysql:host={host};dbname={db}', '{user}', '{password}' );
</pre>
<span class="indent"></span>Pada kode tersebut kita set dulu mode error jadi E_ALL agar dalam mode latihan semua error akan ditampilkan. Untuk memudahkan debugging. Kemudian bisa dilihat kita require file autoload dari composer, supaya semua repository/class yang berada dalam folder vendor dapat kita gunakan.
                    
<span class="indent"></span>Nah, disitu kita juga menggunakan namespace/class Redbean dengan perintah use \RedBeanPHP\R as R;. Kemudian pada baris terakhir kita setup akses ke database latihan kita. Sebelumnya silahkan buat dulu database latihan, misal bernama latihan_orm.
                    
<span class="indent"></span>Jangan lupa untuk menghidupan layanan server dan database. Jika kamu menggunakan XAMPP, silahkan klik start server dan mysql.
                    
<b>Setting Database</b>
<span class="indent"></span>Perhatikan bagian :
<pre class="code">
R::setup( 'mysql:host={host};dbname={db}', '{user}', '{password}' );
</pre>
<span class="indent"></span>Silahkan ganti {host}, {db}, {user}, dan {password} dengan settingan yang ada pada laptop teman-teman. Biasanya untuk pengguna XAMPP Windows user nya adalah root, dan passwordnya kosong. Untuk host, isikan saja dengan localhost.
                    
<b>Insert Data</b>
<span class="indent"></span>Mari kita lanjutkan untuk memasukkan data. Perlu kamu ketahui, Redbean ORM sudah membereskan urusan schema database untuk mu. Kita tidak perlu lagi membuat table-table secara manual. Lanjutkan kode latihan, dengan menyisipkan perintah insert berikut ini :
<pre class="code">
// Kode sebelumnya ...
                
// Insert
$user = R::dispense('users'); // Setting table : users.
$user->name = 'Budi';
$id = R::store($user);
$echo "{$user->name} berhasil terdaftar dengan id {$id}";
</pre>
<span class="indent"></span>Silahkan buka file index.php pada browser kamu (nyalakan dulu XAMPP nya untuk yang Apache server dan MySQL) dan lihatlah apa yang terjadi. Harusnya akan keluar output seperti ini :
<pre class="terminal">
Budi berhasil terdaftar dengan id 1
</pre>
<span class="indent"></span>Buka PhpMyAdmin (atau db manager kamu yang lain). Cek database latihan_orm harusnya akan ada table baru bernama users dan record baru berisi Budi. Magic bukan! Inilah power dari ORM, kita tidak perlu lagi bersentuhan dengan sintaks SQL.
                    
<b>Select Data</b>
<span class="indent"></span>Sekarang kita coba select data dari table yang sudah kita buat. Sebelumnya silahkan input data sebanyak-banyaknya untuk bahan latihan. Nah, untuk select data bisa dilakukan dengan perintah berikut ini :
<pre class="code">
// Kode sebelumnya
                
$user = R::load('users', 1); // Param 1 : nama table, param 2 : id user, bisa kamu ganti berdasarkan field lain.
print_r($user);
</pre>
<span class="indent"></span>Disitu kita coba tuliskan cari data users yang id nya 1. Boom! akan tampil data user yang mempunyai id 1. Sedangkan untuk menampilkan semua data kamu bisa menggunakan sintaks ini :
<pre class="terminal">
// Kode sebelumnya
                
$users = R::findAll( 'users' );
print_r($users);
</pre>

<b>Update Data</b>
<span class="indent"></span>Untuk memperharui data kita harus mengambil dulu object data yang mau dijadikan sasaran. Lalu mengubah property field yang ingin diganti, dilanjutkan dengan memanggil method store. Kurang lebih seperti ini :
<pre class="code">
// Kode sebelumnya
                
$user = R::findOne( 'users', ' name = ? ', [ 'Budi' ] ); // Cari user bernama Budi
$user->name = 'Muhammad'; // Set nama jadi Muhammad
R::store( $user ); // Simpan
</pre>
<span class="indent"></span>Sekarang cek database kamu, harusnya user bernama Budi sekarang sudah berganti menjadi Muhammad.
                    
<b>Delete Data</b>
<span class="indent"></span>Untuk menghapus data sintaksnya cukup simple. Kurang lebih seperti ini :
<pre class="code">
$user = R::findOne( 'users', ' name = ? ', [ 'Muhammad' ] );
R::trash($user);
</pre>       
<span class="indent"></span>Pertama kamu harus mencari object yang mau dihapus. Diatas kita mencari user bernama Muhammad. Lalu dilanjutkan memanggil method trash. Silahkan dicoba, harusnya sekarang record data bernama Muhammad sudah hilang.

<span class="indent"></span>Berikut ini hasil kode yang sudah dirangkai, kamu bisa coba satu persatu, namun jangan lupa untuk uncomment, jangan jalankan semua berbarengan karena akan error.
<pre class="code">
<span class="tagphpbuka"></span>
                    
    ini_set('display_errors', 1); 
    ini_set('display_startup_errors', 1); 
    error_reporting(E_ALL); 
    
    require 'vendor/autoload.php';
    
    use \RedBeanPHP\R as R;
    
    R::setup( 'mysql:host=localhost;dbname=_sample', 'app', '12345678' );
    
    // Insert
    // $user = R::dispense('users');
    // $user->name = 'Budi';
    // $id = R::store($user);
    // echo "{$user->name} berhasil terdaftar dengan id {$id}";
    
    // Get one
    // $user = R::load('users', 1);
    // print_r($user);
    
    // Find All
    // $users = R::findAll( 'users' );
    // print_r($users);
    
    // Wipe all, be CAREFULL.
    // R::nuke();
    
    // Update
    // $user = R::findOne( 'users', ' name = ? ', [ 'Budi' ] );
    // $user->name = 'Muhammad';
    // R::store( $user );
    
    // Delete.
    $user = R::findOne( 'users', ' name = ? ', [ 'Muhammad' ] );
    R::trash($user);
</pre>              
<strong>Penutup</strong>
Demikian gambaran tentang penggunaan Active Record Pattern. Jika kamu sudah fasih menggunakan Redbean kamu bisa lanjutkan mencoba menggunakan ORM lain seperti Doctrine, Propel, dan lain lain.
                    
<span class="indent"></span>Referensi :
<ul>
    <li><a target="_blank" href="https://www.martinfowler.com/eaaCatalog/activeRecord.html">https://www.martinfowler.com/eaaCatalog/activeRecord.html</a></li>
    <li><a target="_blank" href="https://www.youtube.com/watch?v=rzGeNYC3oz0">https://www.youtube.com/watch?v=rzGeNYC3oz0</a></li>
    <li><a target="_blank" href="https://kurapov.ee/eng/tech/ORM-is-harfmul-pattern/">https://kurapov.ee/eng/tech/ORM-is-harfmul-pattern/</a></li>
    <li><a target="_blank" href="https://en.wikipedia.org/wiki/Active_record_pattern">https://en.wikipedia.org/wiki/Active_record_pattern</a></li>
</ul>
                </pre>
            </li>
            <li class="listboxitem" id="37">
                <h2>Facade Pattern</h2>
                <pre>
<strong>Konsep</strong>
<span class="indent"></span>Facade! mungkin untuk penggemar framework Laravel sudah pernah menggunakan teknik ini. Walaupun masih terdapat banyak perdebatan Facade Laravel dengan Facade pada dunia OOP pada umumnya, sangat cukup untuk merasakan pattern Facade.

<span class="indent"></span>Lalu sebenarnya apa sih Facade? Pattern ini merupakan teknik untuk menyembunyikan kerumitan interaksi pada unit program (class, objek), dengan cara membungkusnya pada interface baru. Interface baru ini berupa class baru yang lebih sederhana. Dengan begitu programmer akan lebih mudah berinteraksi dengan class tersebut tanpa harus mempelajari class, class lain dibelakangnya.

<span class="indent"></span>Kurang lebih gambarnya seperti ini :
<img src="https://refactoring.guru/images/patterns/diagrams/facade/structure-indexed-2x.png" alt="Image Facade Pattern">
<span class="indent"></span>Terlihat pada gambar, client (programmer) cukup mengakses sebuah class Facade untuk berinteraksi dengan subsytem yang ada pada program. Dia tidak harus mempelajari semua hal yang ada.

<strong>Praktek tanpa Facade</strong>
<span class="indent"></span>Baik, seperti biasa, kita akan mencoba sebuah program sebelum diterapkannya design pattern. Misal disini kita membuat sebuah program untuk login ke website kita dengan berbagai social media, seperti Twitter, Facebook, Google.

<span class="indent"></span>Perlu dicatat, kode ini adalah ilustrasi saja, sudah semaksimal mungkin mencoba mendekati kasus nyata.

<span class="indent"></span>Mari lihat kode berikut ini :
<pre class="code">
<span class="tagphpbuka"></span>
    // Untuk handle Twitter
    class Twitter {
    
        public function requestToken() {
            echo "Token requested! \n";
        }
    
        public function login() {
            echo "Redirect to Twitter Login Page \n";
        }
    }
    
    // Untuk handle Facebook
    class Facebook {
    
        public function requestToken() {
            echo "Token requested! \n";
        }
    
        public function login() {
            echo "Redirect to Facebook Login Page \n";
        }
    }
    
    // Untuk handle Google
    class Google {
    
        public function requestToken() {
            echo "Token requested! \n";
        }
    
        public function login() {
            echo "Redirect to Google Login Page \n";
        }
    }
    
    // Sekarang kita akan simulasi keinginan users. Ceritanya user memilih mau login dengan apa.
    // Ini hanya kode contoh, misalnya kode ini ada di sebuah Controller (Jika menggunakan Framework)
    // Bisa juga studi kasus pada PHP Native, tanpa framework, berarti ada di sebuah file.
    // Request bisa jadi datang dari POST/GET pada tombol halaman login.
    
    $userOption = 'Google';
    
    if ($userOption == 'Google') {
        $login = new Google;
        $login->requestToken(); 
        $login->login(); 
    } else if ($userOption == 'Twitter') {
        $login = new Twitter;
        $login->requestToken(); 
        $login->login();
    } else {
        $login = new Facebook;
        $login->requestToken(); 
        $login->login();
    }
    ?>
</pre>
<span class="indent"></span>Bisa dilihat pada kode diatas. Kita membuat sebuah 3 class khusus untuk menangani akses API ke Google, Facebook, dan Twitter. Pada masing-masing class kita membuat 2 buah method, yaitu requestToken() yang berfungsi untuk generate token untuk syarat Request API pada server masing-masing brand. Dan satu lagi adalah login() untuk me-redirect login ke halaman masing-masing brand.
<pre class="terminal">
Note : Pada kasus nyata, setelah login di halaman Facebook/Twitter/Google akan diarahkan kembali ke website kita untuk kemudian kita login kan ke website kita.
</pre>
Selanjutnya, pada kode tersebut kita simulasikan Google sebagai pilihan users. Dan menghasilkan output :
<pre class="terminal">
Token requested! 
Redirect to Google Login Page 
</pre>
<span class="indent"></span>Bisa dilihat tidak ada masalah pada kode tersebut. Berjalan normal apa adanya. Namun akan terjadi masalah ketika kita harus menambah class lain, login with LinkedIn/Dll misalnya. Bagaimana jika ada > 10 Social Media? mau berapa dokumentasi program yang akan kamu sediakan untuk rekan kerja, atau orang lain yang akan meneruskan program kamu. Bagaimana jika pada masing masing class cara memanggilnya berbeda beda? tentunya tidak seperti di contoh, hanya dua buah method saja.

Masalah yang mungkin akan terjadi :


<ul>
    <li>Programmer/rekan baru akan repot belajar semua class yang ada.</li>
    <li>Kode pemilihan login (if else/case) akan bertambah panjang pada bagian controller.</li>
    <li>Kamu harus mengurus dan membuka dokumentasi masing-masing class untuk memakai login Social Media</li>
</ul>

<strong>Praktek Facade</strong>
<span class="indent"></span>Mari kita coba terapkan pattern Facade, tambahkan class baru bernama LoginFacade pada kode :
<pre class="code">
<span class="tagphpbuka"></span>
    // Membuat class LoginFacade sebagai interface utama login with Social Media
    class LoginFacade {
        // Untuk menampung pilihan brand.. Facebook? Twitter?
        public $brand;
    
        // Set brand ..
        public function setBrand(string $brand) {
            $this->brand = $brand;
    
            return $this;
        }
    
        // Method untuk menjalankan class real nya. 
        public function run() {
            // Cukup begini, sama dengan `new Facebook` dst
            $brand = new $this->brand; 
    
            // Request token
            $brand->requestToken();
    
            // Login!
            $brand->login();
        }
    }
    
    ...
    // Kode lanjutan
</pre>
<span class="indent"></span>Bisa dilihat kita menjalankan semua operasi login with social media pada kelas Facade. Terdapat beberapa struktur seperti property $brand untuk menampung pilihan login. Lalu ada method setBrand untuk menyimpan hasil pilihan. Yang terakhir adalah method run() yang berisi kode program untuk menjalankan requestToken() dan login()

<span class="indent"></span>Sekarang proses bisnis login sudah dibungkus (Wrap) kedalam class Facade, sehingga untuk berinteraksi dengan login kita cukup mengakses kelas ini saja.

<span class="indent"></span>Lalu bagaimana cara berinteraksi dengan class tersebut, kita bisa tulis dengan cara :
<pre class="code">
// Kode sebelumnya
...

$userOption = 'Twitter';

$login = new LoginFacade;
$login->setBrand($userOption)->run();
</pre>
Sehingga kode lengkapnya menjadi seperti ini :
<pre class="code">
// Facade Social media! Wrapper semua class.
// Kita cukup berkomunikasi dengan class ini saja.
class LoginFacade {

    public $brand;

    public function setBrand(string $brand) {
        $this->brand = $brand;

        return $this;
    }

    public function run() {
        $brand = new $this->brand;
        $brand->requestToken();
        $brand->login();
    }
}

// Untuk handle Twitter
class Twitter {

    public function requestToken() {
        echo "Token requested! \n";
    }

    public function login() {
        echo "Redirect to Twitter Login Page \n";
    }
}

// Untuk handle Facebook
class Facebook {

    public function requestToken() {
        echo "Token requested! \n";
    }

    public function login() {
        echo "Redirect to Facebook Login Page \n";
    }
}

// Untuk handle Google
class Google {

    public function requestToken() {
        echo "Token requested! \n";
    }

    public function login() {
        echo "Redirect to Google Login Page \n";
    }
}

// Sekarang kita akan simulasi keingin users. Ceritanya user memilih mau login dengan apa.
// Ini hanya kode contoh, misalnya kode ini ada di sebuah Controller (Jika menggunakan Framework)
// Bisa juga studi kasus pada PHP Native, tanpa framework, berarti ada di sebuah file.

$userOption = 'Twitter';

$login = new LoginFacade;
$login->setBrand($userOption)->run();
</pre>
Output kode diatas adalah :
<pre class="terminal">
Token requested! 
Redirect to Twitter Login Page 
</pre>
<span class="indent"></span>Cukup tahu cukup tahu method setBrand() dan run() saja untuk login ke berbagai social media. Sangat ramping! Silahkan coba ganti string pada $userOption dengan Google atau Facebook. Kode akan berjalan mulus.

<strong>Kesimpulan</strong>
<span class="indent"></span>Facade berguna sebagai wrapper atau enkapsulasi kerumitan pada program kita. Interface yang tadinya rumit, akan berubah menjadi lebih mudah digunakan. Sehingga kita bisa lebih mudah berkolaborasi secara internal ataupun external.Tentunya kode seperti ini akan lebih maintainable dibanding sebelumnya.

<span class="indent"></span>Referensi :
<ul class="list">
    <li><a target="_blank" href="https://refactoring.guru/design-patterns/facade">https://refactoring.guru/design-patterns/facade</a></li>
</ul>
                </pre>
            </li>
            <li class="listboxitem" id="38">
                <h2>Dependency Injection</h2>
                <pre>
<strong>Konsep</strong>
<span class="indent"></span>Sebelum masuk pembahasan Dependency Injection pattern, teman-teman harus paham dulu apa arti dependency. Dependency adalah ketergantungan. Dalam prakteknya, sebuah komponen pada program seringkali memiliki ketergantungan terhadap komponen lain. Terdapat dua jenis sifat. Pertama, sebuah komponen dapat sepenuhnya bergantung, tidak bisa hidup tanpa komponen lain. Kedua, komponen dapat berdiri sendiri, dia akan memanggil komponen lain pada saat dibutuhkan saja.

<span class="indent"></span>Mari kita lihat contoh lebih nyata, biasanya implementasi pada proyek. Teman-teman terbiasa menggunakan framework? atau baru belajar OOP? contohnya begini :
<ul>
    <li>Kasus pada Framework. Misalnya kita menggunakan sebuah framework populer. Pastinya sering menggunakan controller? ketika ingin mengolah data, pastinya teman-teman memanggil class model bukan? nah saat teman-teman menginstansiasi model pada controller, disitulah bukti bahwa controller itu memiliki dependency.</li>
    <li>Kasus pada Native OOP PHP. Misalnya kita membuat sebuah class User.php. Pada class tersebut teman-teman ingin mengolah database. Tentunya butuh class lain seperti PDO bukan? Nah, berarti disini class User.php memiliki dependency ke class PDO.</li>
</ul>
<span class="indent"></span>Begitulah cara memahami istilah dependency. Mari kita lanjutkan untuk belajar Dependency Injection (DI) lebih dalam. Seperti biasa, kita akan mulai dari contoh program tanpa pattern. Bagi kalian yang sudah paham, dan hanya ingin lihat implementasi pattern langsung, silahkan skip materi "Praktek tanpa DI".

<strong>Praktek Tanpa DI</strong>
<span class="indent"></span>Misalnya kita dalam sebuah proyek besar, membuat sebuah class khusus untuk menangani report. Kurang lebih seperti ini :
<pre class="code">
<span class="tagphpbuka"></span>

/**
    * Class Report
    * 
    * Disini kumpulan kode untuk menangani report.
    */
class Report {

    // Mengambil total omzet berdasarkan bulan ..
    public function getTotalOmzetByMonth() {
        // Kode-kode query dst
        echo "Get omzet, return array \n";
    }

    // Mengambil produk paling populer
    public function getPopularProduct() {
        // Kode-kode query dst
        echo "Get popular product, return array \n";
    }
}

$report = new Report;
$report->getTotalOmzetByMonth();
$report->getPopularProduct();
</pre>
<span class="indent"></span>Output :
<pre class="terminal">
Get omzet, return array 
Get popular product, return array 
</pre>
<span class="indent"></span>Bisa dilihat kita menginstansiasi class kemudian menjalankan kedua buah method yang ada. Pertama, method getTotalOmzetByMonth() untuk mengambil omzet bulanan. Kedua, method getPopularProduct() untuk mengambil data produk paling populer dari Database. Secara default output dari kedua method tersebut adalah array.

<span class="indent"></span>Beberapa bulan kemudian, kita ingin membuat fitur baru, yaitu mengexport report dalam format Excel. Kemudian kita mencari-cari library yang cocok dan menerapkannya pada program. Kurang lebih seperti ini :
<pre class="code">
<span class="tagphpbuka"></span>

// Load dependency
// Ini hanya contoh! biasanya library/class ini terdapat pada file terpisah, lalu kita masukan dengan require/include
// Isinya adalah method untuk produksi file Excel.
class PHPExcel {
    public function export($data) {
        echo "Exporting data to excel format ..\n";
    }
}

/**
    * Class Report
    * 
    * Disini kumpulan kode untuk menangani report.
    */
class Report {

    // Mengambil total omzet berdasarkan bulan ..
    public function getTotalOmzetByMonth() {

        $data = ''; // Contoh saja, harusnya ada isinya

        // Panggil excel
        $PHPExcel = new PHPExcel();
        $PHPExcel->export($data);

        echo "Get omzet, return exported excel path \n";
    }

    // Mengambil produk paling populer
    public function getPopularProduct() {

        $data = ''; // Contoh saja, harusnya ada isinya

        // Panggil excel
        $PHPExcel = new PHPExcel();
        $PHPExcel->export($data);

        echo "Get popular product, return exported excel path \n";
    }
}

$report = new Report;
$report->getTotalOmzetByMonth();
$report->getPopularProduct();
</pre>
<span class="indent"></span>Simple, kita hanya menambahkan class PHPExcel sebagai helper untuk memproduksi excel. Bisa dilihat pada kode. Kita panggil dan instansiasi class Excel pada badan class Report. Kemudian menjalankan perintah export. Tentunya class tersebut hanya khayalan agar teman-teman dapat menjalankan kode ini.

<span class="indent"></span>Output kode tersebut sekarang menjadi :
<pre class="terminal">
Exporting data to excel format ..
Get omzet, return exported excel path 
Exporting data to excel format ..
Get popular product, return exported excel path 
Kode tersebut berjalan lancar sesuai scenario yang sudah kita buat. Namun ...
</pre>
<span class="indent"></span>Cara memprogram seperti ini, dengan cara menginjeksi/instansiasi class dependen langsung di badan program relatif tidak dianjurkan. Terdapat beberapa masalah diantaranya :
<ul>
    <li><b>Tight Coupled</b>, Class Report menjadi sangat bergantung dengan objek konkrit dari class PHPExcel. Jika di kemudian hari kita akan berganti library/class, tentunya kita harus coding ulang semua class yang sudah bergantung. Sangat terasa repotnya jika PHPExcel ini sudah menyebar di berbagai class program kita.</li>
    <li><b>Bad Readability</b>, instansiasi dependen langsung pada class method membuat kode makin sulit dibaca dan dimengerti. Sangat terasa mungkin jika kita bekerja sebagai tim. Rekan kita tidak bisa dengan cepat mengetahui bahwa class tersebut membutuhkan dependen lain.</li>
    <li><b>Hard to Test</b>, unit testing sulit untuk dilakukan pada class Report. Secara teknis kita tidak bisa membangun mock object.</li>
</ul>
<span class="indent"></span>Nah, kita bisa coba menyelesaikan masalah tersebut dengan Dependency Injection pattern.

<strong>Praktek Dengan DI</strong>
<span class="indent"></span>Mari kita coba implementasi dependency injection. Berikut ini langkah-langkahnya :
<ul>
    <li>Hapus instansiasi PHPExcel pada setiap method.</li>
    <li>Buat method baru, berupa konstruktor __constructor dengan parameter type hinting dari class yang dibutuhkan.</li>
    <li>Buat property untuk menampung object dependen.</li>
    <li>Pada konstruktor, assign objek dependen yang dipassing, masukan ke property penampung.</li>
    <li>Gunakan property untuk melakukan export excel.</li>
</ul>
<span class="indent"></span>Kurang lebih kodenya jadi seperti ini :
<pre class="code">
<span class="tagphpbuka"></span>

// Load dependency
// Ini hanya contoh! biasanya library/class ini terdapat pada file terpisah, lalu kita masukan dengan require/include
// Isinya adalah method untuk produksi file Excel.
class PHPExcel {
    public function export($data) {
        echo "Exporting data to excel format ..\n";
    }
}

/**
    * Class Report
    * 
    * Disini kumpulan kode untuk menangani report.
    */
class Report {

    /** Excel */
    protected $phpexcel;

    public function __construct(PHPExcel $phpexcel) {
        // Set phpexcel.
        $this->phpexcel = $phpexcel;
    }

    // Mengambil total omzet berdasarkan bulan ..
    public function getTotalOmzetByMonth() {

        $data = ''; // Contoh saja, harusnya ada isinya

        // Menjalankan export via property.
        $this->phpexcel->export($data);

        echo "Get omzet, return exported excel path \n";
    }

    // Mengambil produk paling populer
    public function getPopularProduct() {

        $data = ''; // Contoh saja, harusnya ada isinya

        // Menjalankan export via property.
        $this->phpexcel->export($data);

        echo "Get popular product, return exported excel path \n";
    }
}

// Membuat instance report beserta konstruktor parameter instance PHPExcel.
$report = new Report(new PHPExcel);

// Jalankan method.
$report->getTotalOmzetByMonth();
$report->getPopularProduct();
</pre>
<span class="indent"></span>Output kode tersebut masih sama saja dengan sebelumnya. Tapi sekarang class Report menjadi lebih clean. Class Report menjadi lebih independen. Ketika kita butuh PHPExcel, tinggal kita instansiasi objeknya pada konstruktor Report. Dengan begini ketika kita mengganti driver atau library, tinggal mengganti new PHPEXcel saja.

<span class="indent"></span>Sebenarnya inti dari DI sangat simple. Yaitu jangan menginstansiasi langsung objek dependen pada class, melainkan memindahkannya menjadi type hinting class.

<strong>Service Container</strong>
<span class="indent"></span>Tahap selanjutnya dari pembahasan DI adalah Service Container. Dengan teknik service container kita dapat menyerahkan management dependency pada komponen terpisah. Komponen ini dapat bertindak cerdas, memilah milih mana dependency dan meng-injectnya secara otomatis pada class yang membutuhkan. Masih belum terbayang?

<span class="indent"></span>Coba lihat kode kita pada latihan sebelumnya :
<pre class="code">
$report = new Report(new PHPExcel);
</pre>
<span class="indent"></span>Dengan implementasi service container, maka kode akan berubah menjadi hanya seperti ini :
<pre class="code">
$container = new Container;
$report = $container->resolve('Report');
</pre>
<span class="indent"></span>Kita tidak perlu lagi menginstansiasi dependency PHPExcel. Sudah otomatis dihandle oleh method resolve(). Lebih ajaib lagi service container dapat membaca keseluruhan dependency pada Lifecyle program. Contoh :
<ul>
    <li>Class Report butuh class PHPExcel</li>
    <li>Class PHPExcel butuh class Config.</li>
    <li>Class Config butuh class Loader.</li>
    <li>Dan seterusnya ...</li>
</ul>




<span class="indent"></span>Semua tingkatan kebutuhan class ini dapat otomatis dipenuhi oleh service container. Teknik ini juga biasa disebut dengan autowiring.

<span class="indent"></span>Untuk mempelajari service container, teman-teman dapat melihat contoh kode pada repository berikut ini https://github.com/gemblue/SimpleDependencyInjection

<strong>Penutup</strong>
<span class="indent"></span>Demikian materi tentang Dependency Injection. Semoga dapat dipahami dan dipraktekkan. Berikut ini beberapa referensi lanjutan yang bisa teman-teman baca :

<span class="indent"></span>Referensi : 
<ul>
    <li><a href="https://medium.com/tech-tajawal/dependency-injection-di-container-in-php-a7e5d309ccc6">https://medium.com/tech-tajawal/dependency-injection-di-container-in-php-a7e5d309ccc6</a></li>
    <li><a href="https://symfony.com/doc/current/service_container.html">https://symfony.com/doc/current/service_container.html</a></li>
    <li><a href="https://www.php-fig.org/psr/psr-11/">https://www.php-fig.org/psr/psr-11/</a></li>
    <li><a href="http://php-di.org/">http://php-di.org/</a></li>
    <li><a href="https://martinfowler.com/articles/injection.html">https://martinfowler.com/articles/injection.html</a></li>
</ul>
                </pre>
            </li>
            <li class="listboxitem" id="39">
                <h2>MySQLi Prosedural</h2>
                <pre>
<span class="indent"></span>PHP memiliki berbagai metode untuk mengirim query SQL kedatabase MySQL. Perintah umum pada SQL seperti SELECT, INSERT, UPDATE dan DELETE dapat digunakan untuk query dan mengelola data. Pada modul kali ini kita akan membahas mengenai penanganan database menggunakan pendekatan berbasis objek atau object oriented. Hal yang menyenangkan tentang pendekatan objek oriented (selanjutnya disingkat oo) adalah bahwa metode dan nama properti lebih mudah dibaca daripada dalam sintaksis prosedural terutama jika kamu memiliki pengalaman koding dengan objek dalam bahasa lain. Konsep dasarnya adalah ketika kita membuat objek mysqli dari kelas mysqli, kemudian dapat memanggil properti dan metodenya untuk melakukan query pada database. untuk lebih mudahnya langsung kita peraktekan saja.

<strong>Membuat Koneksi ke Database</strong>
<span class="indent"></span>pertama mari kita buat koneksi ke database. kita menggunakan kata kunci new untuk membuat objek mysqli. Umumnya akan lebih rapi untuk menyimpan informasi ini dalam file yang disertakan untuk memudahkan pengeditan dan penggunaan kembali. jadi biasanya untuk koneksi ke database lebih mudah ketika file nya dipisah.
<pre class="code">
<span class="tagphptutup"></span>

    $hostname = "xxxx.yourserver.com";
    $username = "xxxx.yourusername";
    $password = "xxxx.yourpassword";
    $database = "xxxx.yourdatabase";
    $mysqli = new mysqli($hostname, $username, $password, $database);
    /* check connection */
    if (mysqli_connect_error()) {
        printf("Connect failed: %s\n", mysqli_connect_error());
        exit();
    }
    //magic quotes logic
    if (get_magic_quotes_gpc())
    {
    function stripslashes_deep($value)
    {
        $value = is_array($value) ?
        array_map('stripslashes_deep', $value) :
        stripslashes($value);
        return $value;
    }
    $_POST = array_map('stripslashes_deep', $_POST);
    $_GET = array_map('stripslashes_deep', $_GET);
    $_COOKIE = array_map('stripslashes_deep', $_COOKIE);
    $_REQUEST = array_map('stripslashes_deep', $_REQUEST);
    }

<span class="tagphptutup"></span>
</pre>

<span class="indent"></span>Pada kodingan diatas, variabel $mysqli adalah objek mysqli, lalu kita akan membuat referensi ke objek ini ketika kita ingin menggunakan database.

<span class="indent"></span>Ketika kita ingin mengunakan konfigurasi database diatas pada sebuah kelas pada PHP maka kita menggunakan kode berikut:
<pre class="code">
include_once('connectToDB.php');
</pre>
<span class="indent"></span>Contoh-contoh dibawah ini tidak dapat digunakan apabila kita tidak memasukan atau melakukan include terhadap file konfigurasi database yang telah kita buat diatas.

<strong>Query Select Sederhana Menggunakan OO MYSQLI</strong>
<span class="indent"></span>Kode dibawah ini akan melakukan operasi query dengan memanggil atau select data dari database lalu hasilnya akan ditampilkan.
<pre class="code">
include_once('connectToDB.php');

$queryFilms = "SELECT filmName, filmDescription FROM movies WHERE filmID = 10";
$resultFilms = $mysqli->query($queryFilms);
$rowFilms = $resultFilms->fetch_assoc();
// then to output
echo "<span class="tagpbuka"></span>{$rowFilms['filmName']}<span class="tagptutup"></span>";
</pre>
<span class="indent"></span>contoh lain ketika kita memiliki ekspektasi bahwa data yang dikeluarkan lebih dari satu record.

<pre class="code">
include_once('connectToDB.php');

$queryFilms = "SELECT * FROM movies ORDER BY movieName";
$resultFilms = $mysqli->query($queryFilms);
//create array to hold the movie names
$movieNameArray = array();
while ($rowFilms = $resultFilms->fetch_assoc()) {
$movieNameArray[] = $rowFilms['filmName'];
}
//Test the content of the array
print_r($movieNameArray);
</pre>

<span class="indent"></span>Untuk mengeluarkan nilai-nilai dari array kita kemudian dapat menggunakan foreach yaitu:
<pre class="code">
foreach($movieNameArray as $value){
echo "<span class="tagpbuka"></span>{$value}<span class="tagptutup"></span>";
}
</pre>

<strong>Query Insert Sederhana Menggunakan OO MYSQLI</strong>
<pre class="code">
include_once('connectToDB.php');

$sql = "INSERT INTO `crud` (firstname, lastname, email, gender, age) VALUES ('$fname', '$lname', '$email', '$gender', '$age')";
$res = $mysqli->query($sql);
if($res){
    echo 'succes';
}else{
    echo 'fail';
}
</pre>
<span class="indent"></span>Potongan kode diatas merupakan contoh sederhana ketika kita ingin memasukan satu record kedalam database.

<strong>Query Update Sederhana Menggunakan OO MYSQLI</strong>
<span class="indent"></span>Untuk mengupdate data kita perlu menggunakan klausa where karena data yang ingin kita update memiliki satu field unik yang membedakannya dengan record yang lain.

<span class="indent"></span>Berikut contoh Update menggunakan OO MYSQLI:
<pre class="code">
include_once('connectToDB.php');

$sql = "UPDATE `crud` SET firstname='$fname', lastname='$lname', email='$email', gender='$gender', age='$age' WHERE id=$id";
$res = $mysqli->query($sql);
if($res){
    echo 'succes';
}else{
    echo 'fail';
}
</pre>

<strong>Query Delete Sederhana Menggunakan OO MYSQLI</strong>
<span class="indent"></span>Potongan kode dibawah ini menunjukan cara sederhana menghapus record pada database kita.
<pre class="code">
include_once('connectToDB.php');

$sql = "DELETE FROM `crud` WHERE id=$id";
$res = mysqli_query($this->connection, $sql);
if($res){
    return true;
}else{
    return false;
}
</pre>
                </pre>
            </li>
            <li class="listboxitem" id="40">
                <h2>MySQLi tetapi with OOP</h2>
            </li>
            <li class="listboxitem" id="41">
                <h2>Menggunakan PDO(PHP Data Object)</h2>
                <pre>
<span class="indent"></span>PDO (PHP Data Object) merupakan ekstensi baru yang ditambahkan dalam PHP 5.1 untuk mengelola basis data adalah PDO (meskipun PDO tersedia dengan PHP 5.0 sebagai Ekstensi PECL). Cara kerjanya dengan menggunakan beberapa driver untuk bekerja dengan mesin database yang berbeda juga. PDO dikembangkan untuk menyediakan antarmuka yang ringan untuk berbagai mesin basis data. Salah satu fitur PDO yang sangat bagus adalah ia berfungsi seperti Layer Akses Data sehingga Anda dapat menggunakan nama fungsi yang sama untuk semua mesin basis data. kamu dapat terhubung ke database yang berbeda menggunakan string DSN (Data Source Name). Dalam contoh berikut ini kita akan terhubung ke database MySQL dan mengambil beberapa data.
<pre class="code">
<span class="tagphpbuka"></span>

$dsn = 'mysql:dbname=test;host=localhost;';
$user = 'user';
$password = 'password';

try {
$pdo = new PDO($dsn, $user, $password);
} 
catch (PDOException $e) 
{
echo 'Connection failed: ' . $e->getMessage();
}

$result = $pdo->query("select * from users");
foreach ($result as $row)
echo $row['name'];
<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>kode diatas cukup merepotkan, bukan? kode diatas hanya terhubung ke server MySQL dengan DSN (di sini terhubung untuk menguji database) dan kemudian menjalankan query. Dan akhirnya kita menampilkan hasilnya.
                    
<span class="indent"></span>Jadi bagaimana jadinya jika kita terhubung ke database SQLite?
<pre class="code">
<span class="tagphpbuka"></span>

$dsn = 'sqlite:abcd.db';

try 
{
    $pdo = new PDO($dsn);
    $pdo->exec("CREATE TABLE users (id int, name VARCHAR)");
    $pdo->exec("DELETE FROM users");
    $pdo->exec("INSERT INTO users (name) VALUES('afif')");
    $pdo->exec("INSERT INTO users (name) VALUES('tipu')");
    $pdo->exec("INSERT INTO users (name) VALUES('robin')");
} 
catch (PDOException $e) {
echo 'Connection failed: ' . $e->getMessage();
}

$result = $pdo->query("select * from users");
foreach ($result as $row)
echo $row['name'];

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Pada kode diatas tidak ada perubahan dalam kode kecuali DSN.
                    
<span class="indent"></span>Kamu juga dapat membuat database SQLite di memori dan melakukan operasi di sana. Mari kita lihat kode berikut:
<pre class="code">
<span class="tagphpbuka"></span>

$dsn = 'sqlite::memory:';

try {
    $pdo = new PDO($dsn);
    $pdo->exec("CREATE TABLE users (id int, name VARCHAR)");
    $pdo->exec("DELETE FROM users");
    $pdo->exec("INSERT INTO users (name) VALUES('afif')");
    $pdo->exec("INSERT INTO users (name) VALUES('tipu')");
    $pdo->exec("INSERT INTO users (name) VALUES('robin')");
} 
catch (PDOException $e) 
{
echo 'Connection failed: ' . $e->getMessage();
}

$result = $pdo->query("select * from users");
foreach ($result as $row)
echo $row['name'];

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Pada kode diatas kita hanya mengganti DSN saja
                    
<strong>Setting DSN untuk Database Engine yang berbeda</strong>
<span class="indent"></span>Mari kita lihat pengaturan DSN untuk database engine yang berbeda untuk terhubung dengan PDO. Driver database yang didukung adalah seperti yang ditunjukkan di bawah ini:
<ul>
    <li>PDO_DBLIB for FreeTDS/Microsoft SQL Server/Sybase</li>
    <li>PDO_FIREBIRD for Firebird/Interbase 6</li>
    <li>PDO_INFORMIX for IBM Informix Dynamic Server</li>
    <li>PDO_MYSQL for MySQL 3.x/4.x/5.x</li>
    <li>PDO_OCI for Oracle Call Interface</li>
    <li>PDO_ODBC for ODBC v3 (IBM DB2, unixODBC and win32 ODBC)</li>
    <li>PDO_PGSQL for PostgreSQL</li>
    <li>PDO_SQLITE for SQLite 3 and SQLite 2</li>
</ul>
<span class="indent"></span>Sekarang kita lihat contoh dari spesifik driver DSN settings:
<pre class="code">
mssql:host=localhost;dbname=testdb
sybase:host=localhost;dbname=testdb
dblib:host=localhost;dbname=testdb
firebird:User=john;Password=mypass;Database=DATABASE.GDE;
                        DataSource=localhost;Port=3050
informix:host=host.domain.com; service=9800;database=common_db; 
server=ids_server; protocol=onsoctcp;EnableScrollableCursors=1

mysql:host=localhost;port=3307;dbname=testdb
mysql:unix_socket=/tmp/mysql.sock;dbname=testdb

oci:mydb
oci:dbname=//localhost:1521/mydb

odbc:testdb
odbc:DRIVER={IBM DB2 ODBC 
DRIVER};HOSTNAME=localhost;PORT=50000;DATABASE=SAMPLE;PROTOCOL=TCPIP;
                                            UID=db2inst1;PWD=ibmdb2;
odbc:Driver={Microsoft Access Driver 
                            (*.mdb)};Dbq=C:\\db.mdb;Uid=Admin

pgsql:dbname=example;user=nobody;password=change_me;host=localhost;
                                            port=5432

sqlite:/opt/databases/mydb.sq3
sqlite::memory:
sqlite2:/opt/databases/mydb.sq2
sqlite2::memory:
</pre>

<strong>Menggunakan Pernyataan Bawaan dengan PDO</strong>
<span class="indent"></span>Menggunakan PDO, kamu dapat menjalankan pernyataan bawaan terhadap database kamu. Manfaatnya sama seperti sebelumnya.Dengan meningkatkan kinerja untuk beberapa panggilan dengan mem-parsing dan men-cache permintaan sisi server dan juga menghilangkan kemungkinan SQL Injection.
                    
<span class="indent"></span>Pernyataan yang disiapkan PDO dapat mengambil variabel yang telah bernama, tidak seperti apa yang telah kita lihat dalam contoh MySQLi.
                    
<span class="indent"></span>Mari kita lihat contoh berikut untuk memahami ini:
<pre class="code">
<span class="tagphpbuka"></span>

$dsn = 'mysql:dbname=test;host=localhost;';
$user = 'username';
$password = 'password';

try {
    $pdo = new PDO($dsn, $user, $password);
} catch (PDOException $e) 
{
echo 'Connection failed: ' . $e->getMessage();
}

$stmt = $pdo->prepare("select id from users where name=:name");
$name = "tipu";
$stmt->bindParam(":name",$name, PDO::PARAM_STR);
$stmt->execute();
$stmt->bindColumn("id",$id);
$stmt->fetch();
echo $id;

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Juga dapat dengan menggunakan contoh seperti dibawah ini:
<pre class="code">
<span class="tagphpbuka"></span>

$dsn = 'mysql:dbname=test;host=localhost;';
$user = 'username';
$password = 'password';

try {
    $pdo = new PDO($dsn, $user, $password);
} 
catch (PDOException $e) 
{
echo 'Connection failed: ' . $e->getMessage();
}

$stmt = $pdo->prepare("select id from users where name=?");
$name = "tipu";
$stmt->bindParam(1,$name, PDO::PARAM_STR);
$stmt->execute();

$stmt->bindColumn("id",$id);
$stmt->fetch();
echo $id;

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>daripada memanggil bindparam(), kamu dapat menggunakan bindvalues() seperti berikut:
<pre class="code">
$stmt->bindValue(1,"tipu", PDO::PARAM_STR);
</pre>

<strong>Memanggil Prosedur Penyimpanan</strong>
<span class="indent"></span>PDO menyediakan cara mudah untuk memanggil prosedur penyimpanan. Yang harus kamu lakukan adalah menjalankan "CALL SPNAME (PARAMS)" melalui metode exec():
<pre class="code">
$pdo->exec("CALL sp_create_user('david')");
</pre>
    
<strong>Fungsi Menarik Lainnya</strong>
<span class="indent"></span>Ada beberapa fungsi menarik lainnya yang tersedia diPDO. Misalnya, lihat daftar di bawah ini:
<ul>
    <li>fetchAll()</li>
    <li>fetchColumn()</li>
    <li>rowCount()</li>
    <li>setFetchMode()</li>
</ul>
<span class="indent"></span>Fungsi fetchAll() dapat mengambil semua record dari set hasil. Mari kita lihat contoh berikut:
<pre class="code">
$stmt = $pdo->prepare("select * from users");
$stmt->execute();
echo "<span class="tagprebuka"></span>";
    print_r($stmt->fetchAll());
echo "<span class="tagpretutup"></span>";
</pre>
<span class="indent"></span>Fungsi fetchColumn() membantu untuk memilih data dari kolom tertentu setelah menjalankan pernyataan. Mari lihat kode berikut:
<pre class="code">
$stmt = $pdo->prepare("select * from users");
$stmt->execute();
while ($name = $stmt->fetchColumn(1))
{
    echo $name."<span class="tagbr"></span>";
}
</pre>
<span class="indent"></span>rowCount() mengembalikan jumlah baris yang terpengaruh setelah melakukan kueri UPDATE atau DELETE. Tetapi, kamu harus ingat bahwa ia mengembalikan jumlah baris yang terpengaruh oleh permintaan terbaru yang dieksekusi.
<pre class="code">
$stmt = $pdo->prepare("DELETE from users WHERE name='Anonymous'");
$stmt->execute();
echo $stmt->rowCount();
</pre>
setFetchMode() membantu kamu mengatur mode pengambilan pernyataan yang disiapkan pada PDO. Nilai yang tersedia adalah:
<ul>
    <li>PDO::FETCH_NUM : Mengambil hasil sebagai array yang diindeks secara numerik</li>
    <li>PDO::FETCH_ASSOC : Mengambil baris sebagai indeks dengan nama kolom sebagai kunci</li>
    <li>PDO::FETCH_BOTH : Mengambil seperti keduanya di atas</li>
    <li>PDO::FETCH_OBJ : Mengambil baris sebagai objek tempat nama kolom ditetapkan sebagai properti.</li>
</ul>
                </pre>
            </li>
            <li class="listboxitem" id="42">
                <h2>Penggunaan Dasar Exception</h2>
                <pre>
<span class="indent"></span>Kata Exception jika kita terjemahkan kedalam bahasa Indonesia adalah pengecualian. Pengecualian terhadap proses bisnis yang tidak berjalan semestinya, atau apapun yang berada diluar ekspektasi keberhasilan. Ketika ada hal diluar ekspektasi, mau diapakan lagi ini resultnya? mau ditampilkan, mau mengerjakan hal lain, atau mau total stop saja eksekusinya.

<span class="indent"></span>Rasanya para programmer baik pemula maupun sudah pengalaman dalam proyek, pastinya sudah pernah menangani pengecualian. Namun memang tidak memanfaatkan fitur Exception dari PHP.

<span class="indent"></span>Contoh, seorang programmer membuat program pengiriman Email. Tapi ketika dieksekusi balikan dari fungsi email adalah false / gagal. Lalu ketika false program memberitahu pesan ke user jika email gagal dikirim karena koneksi timeout atau ada from dan to yang tidak diisi. Contoh lain, misal kita membuat suatu fungsi untuk membaca file csv/txt. Kita program sedemikian rupa untuk mengecek file terlebih dahulu, jika filenya not exist, program memberikan pesan file tidak ada.

<span class="indent"></span>Mari kita coba lihat contoh program yang menghandle pengecualian tapi tidak menggunakan fitur Exception. Disini ceritanya programmer menggunakan teknik return Boolean :
<pre class="code">
<span class="tagphpbuka"></span>

// Membuat fungsi read, isinya program untuk membaca file baris per baris.
function read($file) {

    $output = null;

    if (!file_exists($file)) {
        return false; // Kembalikan false Bool.
    }

    $open = fopen($file, "r");

    fclose($file); // Tutup koneksi

    return fread($open, filesize($file)); // Kembalikan output.
}

$read = read("material.txt");

if ($read == false) {
    echo 'File tidak ditemukan';
} else {
    echo $read;
}

</pre>
<span class="indent"></span>Bisa dilihat program diatas membuat fungsi sederhana untuk baca suatu file. Jika gagal maka return false, jika berhasil return true. Dalam program tersebut jika material.txt ada maka isinya akan ditampilkan, jika file tidak ada akan mengeluarkan output File tidak ditemukan. Programmer menggunakan teknik return false untuk memberitahu ketidaknormalan.

<span class="indent"></span>Pada kasus diatas sebenarnya programmer sudah mengatur pengecualian dengan boolean return. Tentunya kita sering menggunakan teknik ini bukan? Selain bool, array juga biasa dimanfaatkan untuk return ketidaknormalan. Biasanya begini :
<pre class="terminal">
return ['status' => false, 'message' => 'File tidak ditemukan'];
</pre>
<span class="indent"></span>Pernah menggunakan CodeIgniter? framework ini banyak menggunakan return array sebagai output. Misalnya saja saat menggunakan library uploader. Kita harus mengambil pesan error dengan method $this->upload->display_errors()

<span class="indent"></span>Tidak ada yang salah dengan gaya seperti ini, saya pribadi pun masih suka menerapkan handling seperti ini. Programmer PHP memang jarang menggunakan fitur Exception, tidak seperti C++, Java dll. Kutipan dalam e-book PHPTheRightWay pun dikatakan bahwa programmer PHP banyak mengabaikan fitur Exception.

<span class="indent"></span>Mari kita melihat bagaimana jika program tadi kita ubah dengan menerapkan fitur Exception :
<pre class="code">
<span class="tagphpbuka"></span>

error_reporting(E_ALL);
ini_set('display_errors', 1);

// Membuat fungsi read, isinya program untuk membaca file baris per baris.
function read($file) {

    $output = null;

    if (!file_exists($file)) {
        throw new Exception('File tidak ditemukan'); // Throw exception.
    }

    $open = fopen($file, "r");

    fclose($file); // Tutup koneksi

    return fread($open, filesize($file)); // Kembalikan output.
}

$read = read("material.tx"); // Masukan material.tx, harusnya txt, sengaja disalahkan.

if ($read == false) {
    echo 'File tidak ditemukan ..';
} else {
    echo $read;
}

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Disitu kita gantikan return Bool / array dengan throw new Exception. Pada instansiasi Exception kita isi dengan parameter konstruktor pesan File tidak ditemukan. Untuk menggunakan fitur ini harus paham dulu OOP. Sekarang coba copy dan jalankan script tersebut di komputer kamu, dan sengajakan masukan file yang salah. Maka output program akan seperti ini :
<pre class="terminal">
// Pathnya beda beda ya, saya di folder tersebut
Fatal error: Uncaught Exception: File tidak ditemukan in /var/www/html/lab/exception/index.php:12 Stack trace: #0 /var/www/html/lab/exception/index.php(22): read('material.tx') #1 {main} thrown in /var/www/html/lab/exception/index.php on line 12
</pre>
<span class="indent"></span>Error diatas merupakan Uncaught Exception. Yaitu pesan exception yang tidak ditangkap, dengan begini programmer tau sebelah mana titik yang error. Gaya pesannya memang seperti itu, mirip error dan warning PHP. Lalu selanjutnya pesan error ini harus kita tangkap. Caranya begini :
<pre class="code">
<span class="tagphpbuka"></span>

error_reporting(E_ALL);
ini_set('display_errors', 1);

// Membuat fungsi read, isinya program untuk membaca file baris per baris.
function read($file) {

    $output = null;

    if (!file_exists($file)) {
        throw new Exception('File tidak ditemukan'); // Throw exception.
    }

    $open = fopen($file, "r");

    fclose($file); // Tutup koneksi

    return fread($open, filesize($file)); // Kembalikan output.
}

// Block pada try untuk mengeksekusi program jika normal, sedangkan catch akan mengembalikan jika ada Exception.
try {

    $read = read("material.tx");
    echo $read;

} catch (Exception $exception) {
    // Exception pada parameter adalah class type hinting, baca tentang type hinting.
    // Blok ini akan tereksekusi jika ada Exception. Disini kita instansiasi Exception
    echo $exception->getMessage(); // Take pesan dengan method getMessage. Build-in di class Exception.
}

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Maka hasilnya dari error yang gamblang akan berubah menjadi :
<pre class="terminal">
File tidak ditemukan
</pre>
<span class="indent"></span>Mudah bukan? memang akan terasa janggal jika belum terbiasa. Jika kamu ingin menjadi PHP programmer yang baik kamu harus mulai menggunakan Exception Class untuk menangani hal semacam ini. Manfaat dari fitur Exception :
<ul>
    <li><b>Standard</b>, Menggunakan gaya handling error seperti ini sudah dipahami programmer sejagat. Jika kamu bekerja sebagai team, akan lebih mudah untuk teman kamu untuk menghandle pengecualian dari source code kamu. Tidak perlu lagi harus mempelajari array atau bool apa yang kamu tulis.</li>
    <li><b>Rapih</b>, Jika kamu menerapkan Exeption pada setiap lini kode, maka kode handler error kamu akan semakin rapih, tidak lagi perlu ada custom bool atau array.</li>
    <li><b>Modern</b>, Fitur Exception sudah ada sejak versi PHP 5. Sekarang ini sudah PHP 7, kamu masih mau koding dengan cara yang sudah usang? . Di luar sana banyak sekali class/library yang bertebaran, rata rata untuk menggunakan library tersebut kita perlu paham Exception karena mereka sudah menerapkannya. Setidaknya kita tahu paham cara handle errornya. Contohnya saja library Email yang terkenal seperti SwiftMailer</li>
</ul>
                </pre>
            </li>
            <li class="listboxitem" id="43">
                <h2>Membuat Custom Exception</h2>
                <pre>  
<strong>Konsep</strong>
<span class="indent"></span>Pada pelajaran sebelumnya kita telah mempelajari gambaran besar dari Exception, konsep, hingga manfaatnya. Pada materi kali ini kita coba perdalam lagi bagaimana cara menggunakan Exception.

<span class="indent"></span>Beberapa keyword yang harus kamu pahami diantaranya :

<b>Throw</b>
<span class="indent"></span>Keyword throw berguna untuk melempar Exception pada program kita. Gunakan keyword ini jika ada kejanggalan yang mau di return, misal file tidak ketemu, koneksi putus, program error, dsb.

<span class="indent"></span>Penggunaan throw diikuti dengan instansiasi dari class Exception. Dengan penggunaan lengkap :
<pre class="code">
throw new Exception("Pesan");
</pre>
<span class="indent"></span>Baik dalam fungsi atau pada class method kamu tidak perlu lagi menggunakan keyword return jika alur program tidak normal. Lemparkan jika ada kemungkinan potensi error.

<b>Try</b>
<span class="indent"></span>Keyword try berguna untuk mencoba menjalankan blok kode yang mengandung Exception. Jangan gunakan try jika memang dalam blok kode tidak ada proses yang throwable / tidak menerapkan konsep Exception, karena akan sia sia.

<b>Catch</b>
<span class="indent"></span>Keyword catch berguna untuk menangkap Exception yang timbul dalam blok kode try. Kita tinggal atur saja setelah Exception mau dikemanakan lagi. Mau ditampilkan ke user, atau mengubah flow program jika masih ada proses yang panjang dalam kode.

<span class="indent"></span>Keyword ini harus dikawinkan dengan paramater class Exception dengan penulisan :
<pre class="code">
catch (Exception $exception) { // Blok kode kita }
</pre>
<span class="indent"></span>Untuk mengambil pesan kita bisa pakai method $exception->getMessage()

<strong>Finally</strong>
<span class="indent"></span>Pada PHP 5.5 keatas ada fitur baru, yaitu Keyword finally. Cara penulisannya seperti ini :
<pre class="code">
finally { // Blok kode kita }
</pre>
<span class="indent"></span>Blok kode dalam finally akan selalu dieksekusi setelah try dan catch. Gunanya keyword ini adalah menyisipkan proses bisnis yang akan selalu dieksekusi. Tidak peduli program berjalan normal atau ada exception.

<strong>Praktek</strong>
<span class="indent"></span>Mari kita coba semua keyword dengan sample real. Ceritanya kita membuat program untuk meng-scrapping data website orang lain :
<pre class="code">
<span class="tagphpbuka"></span>

    error_reporting(E_ALL);
    ini_set('display_errors', 1);
    
    class Scrapper {
    
        public $url;
        public $output;
    
        // Bikin konstruktor yang set URL
        public function __construct(string $url) 
        {
            $this->url = $url;    
        }
    
        // Menjalankan scrapper.
        public function run() 
        {
            $this->output = file_get_contents($this->url);
    
            if (empty($this->output)) {
                throw new Exception('URL tidak valid, atau konten gagal dimuat');
            }
    
            return $this->output;
        }   
    }
    
    // Mari kita coba.
    try  {
        $scrapper = new Scrapper('https://martinfowler.com');
        echo $scrapper->run();
    } catch (Exception $exception) {
        echo $exception->getMessage();
    } finally {
        echo '<span class="tagboldbuka"></span>Bagian ini akan selalu tereksekusi<span class="tagboldtutup"></span>';
    }
    
<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Pada contoh kali ini kita menggunakan class. Tidak seperti sebelumnya yang murni prosedural. Pada kode tersebut kita membuat sebuah class yang simpel, cuma mengambil data konten website orang lain. Terdapat method __construct dan run pada class tersebut. Pada method run kita throw Exception jika terdapat masalah.

<span class="indent"></span>Lalu perhatikan pada baris selanjutnya kita mencoba menggunakan keyword try catch dan finally. Kurang lebih seperti itu cara penggunannya. Kita tinggal instansiasi objek yang mengandung throwable. Lalu catch pesan. Sedangkan blok kode pada keyword finally akan dijalankan terus menerus. Sangat mudah bukan :) .
                </pre>
            </li>
            <li class="listboxitem" id="44">
                <h2>Multiple Exception</h2>
                <pre>
<span class="indent"></span>Sekarang, mari kita coba bermain lagi dengan class Exception lebih jauh.
                    
<span class="indent"></span>Biasanya dalam sebuah project, terdapat banyak class Exception. Sebuah ExceptionFoo untuk kasus foo, dan ExceptionBar untuk kasus bar. Ini dilakukan agar arsitektur kode lebih maintainable. Berikut ini penjabaran maintanable yang lebih luas :
<ul>
    <li><b>Teamwork</b>, mempermudah kerja team, masing-masing programmer dapat membuat class Exception custom tersendiri. Misal programmer 1 bertugas mengurusi API, sedangkan yang kedua mengurusi Database.</li>
    <li><b>Easy to Read</b>, sebuah class dapat difokuskan untuk Exception tertentu. Jika ada orang lain yang ingin mempelajari dia tinggal buka file yang dimaksud.</li>
    <li><b>Separated</b>, kita dapat mengambil Exception yang berbeda beda pada keyword Catch, sesuai dengan kasusnya.</li>
</ul>                    

<span class="indent"></span>Mari kita coba praktekkan konsep multiple Exception ini, mudah mudahan contoh ini memberikan sample yang mendekati real keadaan dalam proyek. Ceritanya disini kita sedang mengerjakan dua module, registrasi pengguna, dan pengiriman email.
                    
<span class="indent"></span>Pertama-tama kita membuat sebuah class untuk registrasi pengguna. Dalam kasus real biasanya ini adalah module auth, cuma saya akan ambil potongannya saja.
<pre class="code">
<span class="tagphpbuka"></span>
    // Handler register pengguna
    class Registration {
        // Sample saja ya, harusnya kode lebih panjang dengan property name, email, dsb
        public function save() {
            // Disini bisa kode query database native, Query Builder, dll.
            $save = false; // Cuma untuk contoh, false jika gagal, misalnya data double dll.
    
            if ($save == false) {
                // Return Exception .. nanti kita isi.
            }
    
            return true;
        }
    }
<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Lalu class kedua adalah handler untuk email, cuma contoh saja, kodenya dibikin simple :
<pre class="code">
<span class="tagphpbuka"></span>
// Handler email.
class Email {
    // Sama disini juga, cuma contoh ya. Ini method buat kirim email.
    public function send() {
        // False kalau ada gagal kirim seperti data body yang gak terisi. 
        $send = false; 

        if ($send == false) {
            // Return Email Exception .. nanti kita isi.
        }

        return true;
    }
}
<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Nah, disini kita bisa lihat, setiap class memiliki method action bisnis sesuai dengan kepentingannya. Intinya jika registrasi gagal akan melemparkan Exception masing-masing. Registrasi akan melempar Registration Exception, sedangkan email akan melempar Email Exception.
                    
<span class="indent"></span>Sekarang mari kita lengkapi dengan kode Exception terpisah, sehingga kode lengkapnya jadi begini :
<pre class="code">
<span class="tagphpbuka"></span>
error_reporting(E_ALL);
ini_set('display_errors', 1);

// Membuat RegistrationException, di-extend dari Exception class defaultnya PHP.
class RegistrationException extends Exception {
    public function __construct($message) {
        // Modifikasi pesan, khusus registrasi
        parent::__construct("Registration Failure : " . $message);
    }
}

// Membuat EmailException.
class EmailException extends Exception {
    public function __construct($message) {
        // Modifikasi pesan, khusus email
        parent::__construct("Email Failure : " . $message);
    }
}

// Handler register pengguna
class Registration {
    // Save data user, harusnya kode lebih panjang dengan property name, email, dsb
    public function save() {
        // Disini bisa kode query database native, Query Builder, dll.
        // Cuma untuk contoh, false jika gagal kirim atau gagal validasi, misalnya data double dll.
        $save = false; 

        if ($save == false) {
            // Return Registration Exception ..
            throw new RegistrationException('Email sudah terdaftar sebelumnya.');
        }

        // Instansiasi email.
        $email = new Email;

        // Kirim email karena berhasil daftar.
        $email->send(); 

        return true;
    }
}

// Handler email.
class Email {
    // Sama disini juga, cuma contoh ya. Ini method buat kirim email.
    public function send() {
        // False kalau ada gagal kirim seperti data body yang gak terisi. 
        $send = false; 

        if ($send == false) {
            // Return Email Exception ..
            throw new EmailException('Subjek, from, dan to email belum diisi.');
        }

        return true;
    }
}

// Mari kita praktekkan.
$registration = new Registration;

// Jalankan registrasi. Sekali lagi, untuk belajar Exception harap kuasai dulu dasar dasar OOP agar tidak bingung.
try {
    $registration->save();
} catch (RegistrationException $e) {
    // Khusus menangkap exception registration
    echo $e->getMessage();
} catch (EmailException $e) {
    // Khusus menangkap exception email
    echo $e->getMessage();
}
<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Pada kode diatas bisa dilihat kita membuat dua custom Exception dengan cara extend class Exception. Kita dapat memodifikasi pesan Exception dengan template tertentu dengan memanfaatkan konstruktor parent. Dengan begitu setiap Exception akan memiliki ciri khas.
                    
<span class="indent"></span>Lalu kita jalankan try, catch seperti biasanya. Namun disini ada dua catch keyword. Bisa dilihat catch pertama khusus RegistrationException, lalu catch kedua untuk EmailException. Disitu pesan kita cetak saja.
                    
<span class="indent"></span>Kode diatas akan menghasilkan output :
<pre class="terminal">
Registration Failure : Email sudah terdaftar sebelumnya.
</pre>
<span class="indent"></span>Ini disebabkan oleh registrasi method yang mengandung nilai false. Sengaja kita gagalkan dalam kode agar Exception terbaca. Untuk simulasi coba kamu ganti nilai $save menjadi true. Dengan adanya nilai true pada save maka kode akan mengeksekusi email. Dan ketika dijalankan output akan berubah menjadi :
<pre class="terminal">
Email Failure : Subjek, from, dan to email belum diisi.
</pre>
<span class="indent"></span>Email Failure : Subjek, from, dan to email belum diisi.Sampai disini dapat dipahami? Sebenarnya dalam sebuah proyek yang lebih besar kemungkinan juga akan ada method-method tambahan yang dibuat khusus untuk Exception tertentu. Method ini menangani exception yang beragam. Jika penasaran dengan Exception yang lebih kompleks kamu bisa melihat sample code pada framework populer seperti Symfony dan CodeIgniter4.
                    
<span class="indent"></span>Sudah cape kah ? Masih ada materi lanjutannya. Yok sabi lah :) .
                </pre>
            </li>
            <li class="listboxitem" id="45">
                <h2>Throwable</h2>
                <pre>
<span class="indent"></span>PHP versi 7.0 meng-improve beberapa fitur dan behaviour nya. Salah satunya adalah Exception. Mungkin kamu sudah tidak asing lagi dengan istilah Parse Error, Fatal Error, dan error-error lainnya yang seketika muncul ketika kamu salah koding. Halaman yang mengagetkan ini biasa kita lihat ketika memprogram.
                    
<span class="indent"></span>Kalau sebelumnya ketika muncul error seperti demikian kita hanya pasrah dan melakukan debug. Nah, semenjak PHP 7.0 kita bisa injeksi alur errornya dengan cara menangkapnya. Dengan demikian kita bisa membuat halaman error yang lebih friendly, mengubah alur program dengan menjalankan module tertentu, atau hal lainnya.
                    
<span class="indent"></span>Mengapa bisa demikian? karena engine PHP utama sudah menggunakan Exception untuk dirinya sendiri. Semua error sekarang merupakan tanggung jawab class Error. Terdapat 2 class utama dalam Exception PHP. Pertama, class Exception (kita sudah praktekkan pada materi sebelumnya) dan kedua adalah class Error. Kedua-duanya menerapkan interface yang bernama Throwable. Lupa tentang Interface? silahkan mengulang kembali materi tentang Interface pada PHP.
                    
<span class="indent"></span>Mari kita coba kode berikut ini :
<pre class="code">
<span class="tagphpbuka"></span>
ini_set('display_errors', 1);
ini_set('display_startup_errors', 1);
error_reporting(E_ALL);

$url = 'https://www.bengak.com';
echo file_get_contents($url);
</pre>
<span class="indent"></span>Pastinya kamu sering menggunakan fungsi file_get_contents. Jika kamu jalankan script akan menghasilkan output website Codepolitan. Sekarang mari kita salahkan pemanggilannya, dengan typo :
<pre class="code">
<span class="tagphpbuka"></span>
ini_set('display_errors', 1);
ini_set('display_startup_errors', 1);
error_reporting(E_ALL);

// Harusnya file_get_contents.
echo file_contents('https://www.bengak.com');
</pre>
<span class="indent"></span>Dengan pemanggilan yang typo script akan menghasilkan output error begini :
<code class="terminal">
Fatal error: Uncaught Error: Call to undefined function file_contents() in /var/www/html/lab/exeption/index.php:6 Stack trace: #0 {main} thrown in /var/www/html/lab/exeption/index.php on line 6
</code>
<span class="indent"></span>Disini mesin PHP mengembalikan output error yang uncaught (tidak terambil). Semenjak PHP 7.0 bunyi pesannya banyak mengatakan kata kunci Uncaught, karena PHP 7.0 sudah menerapkan Exception pada Error. Seperti saya katakan sebelumnya, di PHP 5 error seperti ini hanya untuk dipasrahkan saja dan lakukan debugging.
                    
<span class="indent"></span>Tapi di PHP 7.0 bisa kita ubah polanya dengan cara try catch dengan interface Throwable :
<pre class="code">
<span class="tagphpbuka"></span>
ini_set('display_errors', 1);
ini_set('display_startup_errors', 1);
error_reporting(E_ALL);

// Kode ini hanya akan berjalan pada PHP 7.0 keatas.
// Untuk mencoba kode ini di PHP 4, 5 atau 7 kamu bisa gunakan situs http://sandbox.onlinephpfunctions.com
try {
    echo file_contents('https://www.bengak.com');
} catch (Throwable $t) {
    echo $t->getMessage();
    // Or lakukan hal lain. Bla bla.
}
</pre>
<span class="indent"></span>Output kode diatas adalah :
<pre class="code">
Call to undefined function file_contents()
</pre>
<span class="indent"></span>Pada kode catch kita hanya menampilkan output, kamu bisa menambahkan logika lain yang kamu butuhkan saat proyek. Yang barusan kita tangani adalah Fatal Error, disini kamu bisa juga menghandle error mesin PHP lainnya seperti TypeError, ParseError, DivisionByZero, ArithmeticError, dan seterusnya.
                    
<span class="indent"></span>Mungkin sebagian dari kamu akan bertanya-tanya, untuk apa mengubah alur error core PHP, atau menangani error yang sudah fatal karena kesalahan programmer sendiri. Harusnya error nya di debug, bukan ditangkap dan diubah alurnya. Lebih masuk akal jika menghandle Exception untuk alur bisnis level proyek sendiri, misal gagal registrasi, gagal login, gagal fetch API, dsb.
                    
<span class="indent"></span>Untuk menjawab ini saya akan mencoba menyampaikan contoh lain, perhatikan kode berikut ini :
<pre class="code">
<span class="tagphpbuka"></span>
ini_set('display_errors', 1);
ini_set('display_startup_errors', 1);
error_reporting(E_ALL);

// Ceritanya diambil dari POST FORM.
// Sengaja kita salahkan value yang seharusnya int menjadi string.
$_POST['fee'] = 'SAMPLE WRONG VALUE'; 

function calculateBonus(string $name, int $fee, int $month) {
    echo 'Name  : ' . $name . '<br/>';
    echo 'Bonus : ' . number_format($fee * $month);
}
calculateBonus('Budi', $_POST['fee'], 12);
</pre>
<span class="indent"></span>Pada kode diatas kita membuat sebuah fungsi yang berguna untuk menghitung jumlah bonus orang, parameternya adalah nama, fee, dan total bulan dia bekerja. Mungkin pada format lain fungsi ini bisa jadi sebuah method dalam sebuah class. Bisa kamu lihat kita menggunakan type hinting pada setiap parameter. Fitur ini berguna untuk memberitahu programmer lain tipe paramater yang diterima. Juga mendisplinkan diri untuk mempassing value yang benar.
                    
<span class="indent"></span>Kemudian kamu coba lihat data POST, sengaja kita masukan string untuk parameter fee agar terjadi error. Jika kamu jalankan tanpa try, catch program ini akan menghasilkan fatal error :
<pre class="terminal">
Fatal error: Uncaught TypeError: Argument 2 passed to calculateBonus() must be of the type integer, string given, called in /var/www/html/lab/exeption/index.php on line 12 and defined in /var/www/html/lab/exeption/index.php:8 Stack trace: #0 /var/www/html/lab/exeption/index.php(12): calculateBonus('Budi', 'HEHE', 12) #1 {main} thrown in /var/www/html/lab/exeption/index.php on line 8
</pre>              
<span class="indent"></span>Potensi ini bisa terjadi jika user tidak memasukan data yang valid. Misalnya datang dari sebuah form. Oke, bagaimana jika sudah divalidasi pada sisi HTML/JS? tetap saja yang namanya validasi harus dilakukan juga di sisi server untuk keamanan data.
<span class="indent"></span>Error type hinting ini tidak bisa dihandle dengan melakukan if else seperti biasanya. Jika ingin menghandle error ini wajib menangkap exception dari mesin PHP. Sehingga kodenya harus kita ubah menjadi seperti ini :
<pre class="code">
    
<span class="tagphpbuka"></span>
ini_set('display_errors', 1);
ini_set('display_startup_errors', 1);
error_reporting(E_ALL);

// Ceritanya diambil dari POST FORM.
// Sengaja kita salahkan value yang seharusnya int menjadi string.
$_POST['fee'] = 'SAMPLE WRONG VALUE'; 

function calculateBonus(string $name, int $fee, int $month) {
    echo 'Name  : ' . $name . '<span class="tagbr"></span>';
    echo 'Bonus : ' . number_format($fee * $month);
}

try {
    calculateBonus('Budi', $_POST['fee'], 12);
} catch (Throwable $t) {
    echo 'Pastikan semua field mengikuti tipe data yang benar.';
}
<span class="tagphpbuka"></span>
</pre>
<span class="indent"></span>Output kode diatas adalah :
<pre class="terminal">
Pastikan semua field mengikuti tipe data yang benar.
</pre>
<span class="indent"></span>Sekarang output terlihat lebih friendly. Output ini bisa kita jadikan alert dalam bentuk Ajax, ataupun tampilan HTML untuk dibaca oleh user.

<span class="indent"></span>Demikian materi tentang Exception Throwable. Semoga kamu bisa memahaminya dengan baik.

<span class="indent"></span>Sumber Inspirasi : <a target="_blank" href="https://trowski.com/2015/06/24/throwable-exceptions-and-errors-in-php7/">https://trowski.com/2015/06/24/throwable-exceptions-and-errors-in-php7/</a>
                </pre>
            </li>
            <li class="listboxitem" id="46">
                <h2>Kegunaan Reflection</h2>
                <pre>
<strong>Kegunaan Reflection</strong>
<span class="indent"></span><b>Reflection</b> pada pengembangan aplikasi website merupakan sesuatu yang cukup sering digunakan, tetapi sepertinya jarang menjadi topik yang diajarkan ketika belajar bagaimana menulis kode. <b>Reflection</b> benar-benar hanya sebuah konsep yang kita temui di sepanjang menulis kode.

<span class="indent"></span><b>Reflection</b>, seperti namanya, adalah kemampuan untuk program komputer untuk memeriksa dirinya sendiri dan memberi tahu kamu tentang properti, metode, dan jenis objek yang kamu kerjakan. Cara ini berguna dalam sbeberapa cara dan skenario yang berbeda.

<span class="indent"></span>Salah satu cara paling umum dimana <b>Reflection</b> berguna adalah untuk men-debug kode. Kamu mungkin menggunakan fungsi get_class() dan get_class_methods() saat bekerja dengan objek yang memiliki nama ambigu. Kemampuan untuk mendapatkan jenis atau metode suatu objek ketika kamu tidak tahu apa jenis objeknya,disebut Reflection.

<span class="indent"></span>mari kita lihat kode program berikut:
<pre class="code">
<span class="tagphpbuka"></span>
// An unknown object appeared!  
var_dump(get_class($pokemon)); // Pokemon\Electricity\Pikachu

var_dump(get_class_methods($pokemon));  
// Tail Whip  
// Thunder Bold  
// Thunder  
<span class="tagphpbuka"></span>
</pre>
<span class="indent"></span>Fungsi get_class() akan mengembalikan string dari nama kelas dan fungsi get_class_methods() akan mengembalikan array metode yang tersedia pada objek.

<span class="indent"></span>kode diatas merupakan pengunaan yang paling umum pada reflection

<span class="indent"></span>Sumber Referensi: <a target="_blank" href="https://culttt.com/2014/07/02/reflection-php/">https://culttt.com/2014/07/02/reflection-php/</a>
                </pre>
            </li>
            <li class="listboxitem" id="47">
                <h2>Reflection Method</h2>
                <pre>
<strong>Reflection Method</strong>
<span class="indent"></span>Reflection Method adalah kelas yang digunakan untuk menyelidiki metode apa pun dari kelas dan kemudian memintanya. Mari kita lihat struktur kelas ini:
<pre class="code">
<span class="tagphpbuka"></span>

    class ReflectionMethod extends ReflectionFunction
    {
    public __construct(mixed class, string name)
    public string __toString()
    public static string export(mixed class, string name, bool return)
    public mixed invoke(stdclass object, mixed args)
    public mixed invokeArgs(stdclass object, array args)
    public bool isFinal()
    public bool isAbstract()
    public bool isPublic()
    public bool isPrivate()
    public bool isProtected()
    public bool isStatic()
    public bool isConstructor()
    public bool isDestructor()
    public int getModifiers()
    public ReflectionClass getDeclaringClass()

    // Inherited from ReflectionFunction
    final private __clone()
    public string getName()
    public bool isInternal()
    public bool isUserDefined()
    public string getFileName()
    public int getStartLine()
    public int getEndLine()
    public string getDocComment()
    public array getStaticVariables()
    public bool returnsReference()
    public ReflectionParameter[] getParameters()
    public int getNumberOfParameters()
    public int getNumberOfRequiredParameters()
    }

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Metode paling penting dari kelas ini adalah getNumberOfParamaters, getNumberOfRequiredParameters, getParameters, dan invoke. Tiga kelas yang pertama ini cukup jelas; mari kita lihat yang keempat yang dipanggil. Ini adalah contoh yang bagus diberikan oleh Manual PHP:

<pre class="code">
<span class="tagphpbuka"></span>
    
    class Counter
    {
    private static $c = 0;

    /**
        * Increment counter
        *
        * @final
        * @static
        * @access  public
        * @return  int
        */
    final public static function increment()
    {
        return ++self::$c;
    }
    }
    // Create an instance of the Reflection_Method class
    $method = new ReflectionMethod('Counter', 'increment');
    // Print out basic information
    printf(
    "===> The %s%s%s%s%s%s%s method '%s' (which is %s)\n" .
    "     declared in %s\n" .
    "     lines %d to %d\n" .
    "     having the modifiers %d[%s]\n",
        $method->isInternal() ? 'internal' : 'user-defined',
        $method->isAbstract() ? ' abstract' : '',
        $method->isFinal() ? ' final' : '',
        $method->isPublic() ? ' public' : '',
        $method->isPrivate() ? ' private' : '',
        $method->isProtected() ? ' protected' : '',
        $method->isStatic() ? ' static' : '',
        $method->getName(),
        $method->isConstructor() ? 'the constructor' : 
                                        'a regular method',
        $method->getFileName(),
        $method->getStartLine(),
        $method->getEndline(),
        $method->getModifiers(),
        implode(' ', Reflection::getModifierNames(
                                    $method->getModifiers()))
        );

        // Print documentation comment
        // printf("
</pre>
                </pre>
            </li>
            <li class="listboxitem" id="48">
                <h2>Reflection Parameter</h2>
                <pre>
<span class="indent"></span>Objek lain yang sangat penting dalam keluarga refleksi adalah ReflectionParameter. Menggunakan kelas ini kamu dapat menganalisis parameter metode apa pun dan mengambil tindakan yang sesuai. Mari kita lihat struktur objek:
<pre class="code">
<span class="tagphpbuka"></span>

    class ReflectionParameter implements Reflector
    {
    final private __clone()
    public object __construct(string name)
    public string __toString()
    public static string export(mixed function, mixed parameter, 
                                                        bool return)
    public string getName()
    public bool isPassedByReference()
    public ReflectionFunction getDeclaringFunction()
    public ReflectionClass getDeclaringClass()
    public ReflectionClass getClass()
    public bool isArray()
    public bool allowsNull()
    public bool isPassedByReference()
    public bool getPosition()
    public bool isOptional()
    public bool isDefaultValueAvailable()
    public mixed getDefaultValue()
    }

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Untuk mempermudah, lihat contoh berikut untuk melihat bagaimana cara kerjanya:
<pre class="code">
<span class="tagphpbuka"></span>

function foo($a, $b, $c) { }
function bar(Exception $a, &$b, $c) { }
function baz(ReflectionFunction $a,  $b = 1, $c = null) { }
function abc() { }

// Create an instance of Reflection_Function with the
// parameter given from the command line.    
$reflect = new ReflectionFunction("baz");
echo $reflect;
foreach ($reflect->getParameters() as $i => $param) 
{
printf(
    "-- Parameter #%d: %s {\n".
    "   Class: %s\n".
    "   Allows NULL: %s\n".
    "   Passed to by reference: %s\n".
    "   Is optional?: %s\n".
    "}\n",
    $i, 
    $param->getName(),
    var_export($param->getClass(), 1),
    var_export($param->allowsNull(), 1),
    var_export($param->isPassedByReference(), 1),
    $param->isOptional() ? 'yes' : 'no'
);
}

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Jika kamu menjalankan kode di atas, kamu akan mendapatkan output berikut:
<pre class="terminal">
Function [ <span class="taghtmlbuka"></span>user> <span class="taghtmlbuka"></span>visibility error> function baz ] 
{
@@ C:\OOP with PHP5\Codes\ch5\test.php 4 - 4
- Parameters [3] 
{
    Parameter #0 [ <span class="taghtmlbuka"></span>required> ReflectionFunction &$a ]
    Parameter #1 [ <span class="taghtmlbuka"></span>optional> $b = 1 ]
    Parameter #2 [ <span class="taghtmlbuka"></span>optional> $c = NULL ]
}
}
-- Parameter #0: a 
{
Class: ReflectionClass::__set_state(array(
'name' => 'ReflectionFunction',
))
Allows NULL: false
Passed to by reference: true
Is optional?: no
}
-- Parameter #1: b 
{
Class: NULL
Allows NULL: true
Passed to by reference: false
Is optional?: yes
}
-- Parameter #2: c 
{
Class: NULL
Allows NULL: true
Passed to by reference: false
Is optional?: yes
}
</pre>
<span class="indent"></span>memang pada reflection sulit dimengerti akan tetapi kenyataannya pada penggunaan reflection begitu mudah, sehingga biasanya kita tidak menyadari bahwa ketika kita melakukan pengkodean ternyata kita sedang menggunakan reflection
                </pre>
            </li>
            <li class="listboxitem" id="49">
                <h2>Reflection Property</h2>
                <pre>
<span class="indent"></span>Reflection Property merupakan yang terakhir di bawah refleksi keluarga yang akan kita diskusikan di sini. Kelas ini membantu kamu untuk menyelidiki properti kelas dan merekayasa balik mereka. Kelas ini memiliki struktur sebagai berikut:
<pre class="code">
<span class="indent"></span>
<span class="tagphpbuka"></span>

class ReflectionProperty implements Reflector {
final private __clone()
public __construct(mixed class, string name)
public string __toString()
public static string export(mixed class, string name, bool return)
public string getName()
public bool isPublic()
public bool isPrivate()
public bool isProtected()
public bool isStatic()
public bool isDefault()
public int getModifiers()
public mixed getValue(stdclass object)
public void setValue(stdclass object, mixed value)
public ReflectionClass getDeclaringClass()
public string getDocComment()
}
?>
</pre>
<span class="indent"></span>Berikut adalah contoh yang diambil langsung dari Manual PHP, yang membantu menjelaskan cara kerjanya.
<pre class="code">
<span class="tagphpbuka"></span>

class String {
    public $length  = 5;
}

// Create an instance of the ReflectionProperty class
$prop = new ReflectionProperty('String', 'length');
// Print out basic information
printf(
"===> The%s%s%s%s property '%s' (which was %s)\n" .
"     having the modifiers %s\n",
    $prop->isPublic() ? ' public' : '',
    $prop->isPrivate() ? ' private' : '',
    $prop->isProtected() ? ' protected' : '',
    $prop->isStatic() ? ' static' : '',
    $prop->getName(),
    $prop->isDefault() ? 'declared at compile-time' : 
                                    'created at run-time',
    var_export(Reflection::getModifierNames(
                                $prop->getModifiers()), 1)
    );  

// Create an instance of String
$obj= new String();

// Get current value
// printf("
</pre>
                </pre>
            </li>
            <li class="listboxitem" id="50">
                <h2>Menerapkan Unit Testing</h2>
                <pre>
<strong>Keuntungan Menerapkan Unit Testing</strong>
<span class="indent"></span>Bagian lain yang sangat penting dari pemrograman adalah pengujian unit atau unit testing, di mana kamu dapat menguji potongan kode, apakah itu berfungsi dengan baik atau tidak. Kamu dapat menulis kasus uji terhadap versi kode kamu untuk memeriksa apakah kode kamu berfungsi setelah refactoring. Saat kamu membuat kode aplikasi kamu, unit test berfungsi sebagai kerangka. Unit testing adalah bagian wajib dari pemrograman untuk programmer dari setiap bahasa. Ada paket pengujian unit yang tersedia untuk hampir semua bahasa pemrograman.

<span class="indent"></span>Unit testing memiliki banyak manfaat, beberapa di antaranya adalah:
<ul class="list">
    <li>Memastikan konsistensi dari aplikasi.</li>
    <li>Memastikan kemampuan kerja aplikasi lengkap kamu setelah segala jenis refactoring.</li>
    <li>Periksa redundansi dan menghapusnya dari kode kamu.</li>
    <li>Mudah mencari tahu di mana masalahnya.</li>
    <li>Mempercepat proses debug jika terjadi kesalahan.</li>
    <li>Minimalkan upaya dokumentasi dengan memberikan contoh-contoh kerja dari API kamu.</li>
    <li>Membantu melakukan uji regresi sehingga tidak terjadi regresi lagi.</li>
</ul>
<span class="indent"></span>Beberapa bug hanya dapat mengganggu pengguna, beberapa bug menghentikan fungsi, dan beberapa kerentanan bug memakan sumber daya yang besar. Mari kita perhatikan contoh berikut ini. Kamu telah menulis sebuah fungsi yang mengambil dua parameter dan memperbarui database yang sesuai. Parameter pertama adalah nama bidang dan parameter kedua adalah nilai bidang yang dengannya harus menemukan data dan kemudian memperbaruinya. Sekarang mari kita buat:
<pre class="code">
function selectUser($field, $condition) {
    if (!empty($condition))
    {
        $query = "{$field}= '{$condition}'";
    }
    else
    { 
        $query = "{$field}";
    }

    echo "select * from users where {$query}";

    $result = mysql_query("select * from users where {$query}");
    $results = array();

    while ($data = mysql_fetch_array($result))
    {
        $results[] = $data;
    }

    return $results;
}
</pre>
Ketika kamu memanggilnya seperti ini, itu menunjukkan data tertentu:
<pre class="code">
print_r(selectUser("id","1");
</pre>
<span class="indent"></span>Output:
<pre class="terminal">
(
    [0] => Array
        (
        [0] => 1
        [id] => 1
        [1] => afif
        [name] => afif
        [2] => 47bce5c74f589f4867dbd57e9ca9f808
        [pass] => 47bce5c74f589f4867dbd57e9ca9f808
        )
)
</pre>
<span class="indent"></span>Tetapi jika dipanggil seperti ini:
<pre class="code">
print_r(selectUser("id",$_SESSION['id']);
</pre>
<span class="indent"></span>akan mengeluarkan output seperti di bawah ini:
<pre class="terminal">
[0] => Array
    (
        [0] => 1
        [id] => 1
        [1] => afif
        [name] => afif
        [2] => 47bce5c74f589f4867dbd57e9ca9f808
        [pass] => 47bce5c74f589f4867dbd57e9ca9f808
    )
[1] => Array
    (
        [0] => 2
        [id] => 2
        [1] => 4b8ed057e4f0960d8413e37060d4c175
        [name] => 4b8ed057e4f0960d8413e37060d4c175
        [2] => 74b87337454200d4d33f80c4663dc5e5
        [pass] => 74b87337454200d4d33f80c4663dc5e5
    )
</pre>
<span class="indent"></span>Contoh di atas bukan output yang benar dan seperti yang terjadi di runtime jika itu update, bukan select query, seluruh data kamu bisa rusak. Jadi bagaimana kamu memastikan bahwa output selalu valid? Baiklah, kita akan melakukannya dengan mudah dengan pengujian unit di materi selanjutnya.
                </pre>
            </li>
            <li class="listboxitem" id="51">
                <h2>Mempersiapkan Unit Testing</h2>
                <pre>
<strong>Mempersiapkan Unit Testing</strong>
<span class="indent"></span>Untuk menulis unit testing yang berhasil untuk aplikasi PHP biasanya menggunakan PHPUnit, kamu perlu mengunduh paket, mengkonfigurasinya, dan kemudian melakukan beberapa tugas kecil sebelum benar-benar dapat menjalankan tes kamu. baik, kita mulai.

<span class="indent"></span>Kamu dapat menjalankan tes PHPUnit dari baris perintah atau dari dalam skrip kamu. Untuk saat ini kita akan menjalankan pengujian dari dalam skrip kami, tetapi di bagian selanjutnya, kita akan belajar cara menjalankan pengujian unit dari baris perintah.

<span class="indent"></span>Untuk memulai, unduh paket dari <a target="_blank" href="http://www.phpunit.de">http://www.phpunit.de</a>  dan ekstrak di include path kamu. Jika kamu tidak yakin apa include path, kamu bisa mendapatkannya dari pengaturan include_path di php.ini kamu. Atau Kamu dapat menjalankan skrip PHP berikut untuk menampilkan output:
<pre class="code">
<span class="tagphpbuka"></span>
    echo get_include_path()
<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Sekarang ekstrak arsip PHPUnit dan letakkan folder PHPUnit di folder, yang ada di include path kamu. Folder PHPUnit ini berisi dua folder lain bernama PHPUnit dan PHPUnit2.

<span class="indent"></span>Sekarang kamu telah selesai mempersiapkan unit testing selanjutnya kita akan menggunakan unit testing tersebut.
                </pre>
            </li>
            <li class="listboxitem" id="52">
                <h2>Membuat Unit Testing</h2>
                <pre>
<strong>Pengantar</strong>
<span class="indent"></span>Unit Testing sebenarnya adalah kumpulan tes yang berbeda terhadap kode kamu. Bukan pekerjaan yang sulit untuk menulis unit test. Untuk mempraktekkan unit testing kita membutuhkan tools untuk mengetest. Di dunia PHP ada salah satu tools yang populer, adalah PHPUnit. Di materi ini kita akan mempraktekkanya. Yang harus Kamu lakukan hanyalah mengikuti serangkaian konvensi. Kita akan mencoba membuat sebuah class sederhana untuk testing, lalu kita integrasikan dengan PHPUnit.

<span class="indent"></span>Untuk belajar materi ini kamu diharapkan sudah paham :
<ul class="list">
    <li>PHP</li>
    <li>OOP</li>
    <li>CLI Command pada Windows / Linux</li>
    <li>Composer</li>
</ul>
<span class="indent"></span>Bagi yang merasa sudah paham 4 point diatas kita coba lanjutkan. Buatlah sebuah folder dengan nama latihan-php-unit. Jika sudah, silahkan masuk ke direktori latihan tersebut dengan CLI masing-masing dengan perintah cd. Bagi yang menggunakan GUI/Window, silahkan masuk ke folder tersebut dengan mengkliknya.

<strong>Instalasi PHP Unit</strong>
<span class="indent"></span>Pertama-tama kita membutuhkan framework PHPUnit. Halaman website PHPUnit dapat ditemukan pada alamat https://phpunit.de/. Saat ini PHPUnit sudah mencapat versi 9. Nah, untuk latihan kali ini kita akan gunakan versi 8 yang terdaftar secara default pada repository Composer. Silahkan buka folder latihan-php-unit, lalu jalankan perintah ini pada CLI :
<pre class="code">
composer require phpunit/phpunit
</pre>
<span class="indent"></span>Tampilannya akan terlihat seperti ini :
<img src="https://cdn-cdpl.sgp1.digitaloceanspaces.com/original/120478/6.png" alt="Tampilan Install PHPUnit dengan Composer">
<span class="indent"></span>Jika kamu buka folder latihan-php-unit sekarang akan terisi file composer.json, composer.lock beserta folder vendor. Sampai sini kita sudah berhasil meinstall PHP Unit.

<span class="indent"></span>Kemudian jika sudah terInstall kita bisa membukanya di text editor masing-masing, disini saya buka foldernya dengan menggunakan VSCode sebagai text editornya.

<strong>Membuat Class Contoh</strong>
<span class="indent"></span>Pada dunia nyata dalam proyek seringkali kita membuat class. Baik pekerjaan native ataupun menggunakan framework. Misalnya membuat controller, model, ataupun library. Dalam kasus sekarang kita ceritanya mempunyai sebuah library yang ingin kita test. Library ini kita beri nama Wordcount.php. Yang berisi sebuah method untuk menghitung jumlah kata dalam kalimat.

<span class="indent"></span>Silahkan buat sebuah file bernama Wordcount.php berisi kode berikut :
<pre class="code">
<span class="tagphptutup"></span>

// File : WordCount.php
class Wordcount
{
    public function countWords($sentence)
    {
        return count(explode(" ",$sentence));
    }
}

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Terlihat sederhana? kita hanya membuat sebuah method bernama countWords yang memecah string menjadi array, lalu menghitung jumlah array tersebut, kemudian mengembalikan nilai jumlahnya.

<strong>ongMembuat Test</strong>
<span class="indent"></span>Tidak berlama-lama, langsung saja kita buat kode untuk testingnya. Untuk membuat test kita membutuhkan komponen class dari PHPUnit. Komponen tersebut sudah terinstall dalam folder vendor saat menjalankan Composer.

<span class="indent"></span>Sekarang buatlah file bernama SimpleTest.php pada folder latihan-php-unit berisi kode berikut ini :
<pre class="code">
<span class="tagphptutup"></span>

// Path to run ./vendor/bin/phpunit --bootstrap vendor/autoload.php FileName.php
// Butuh Framework PHPUnit
use PHPUnit\Framework\TestCase;

// Class yang mau di TEST.
require_once "Wordcount.php";

// Class untuk run Testing.
class SimpleTest extends TestCase
{
    public function testCountWords()
    {
        // Kita pakai class yang mau kita test.
        $Wc = new WordCount();

        // Kita masukan parameter 4 kata, yang harusnya dapat output 4.
        $TestSentence = "My name is Joko"; // 4 Kata ..
        $WordCount = $Wc->countWords($TestSentence);

        // Kita assert equal, ekspektasi nya harus 4, jika benar berarti Wordcount berfungsi dengan baik.
        $this->assertEquals(4, $WordCount); 
    }
}

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Pada kode tersebut kita use komponen PHPUnit yang sudah ada dalam folder vendor. Lalu kita juga require class yang sudah kita bikin sebelumnya yaitu Wordcount.php.

<span class="indent"></span>Dalam kode kita juga membuat class bernama SimpleTest yang meng-extend TestCase milik PHPUnit. Dalam penggunaannya, kita minimal harus membuat sebuah method dalam TestCase, disini kita berinama testCountWords.

<span class="indent"></span>Sebenernya penamaannya bebas terserah teman-teman, nama pada contoh diatas adalah nama yang paling relevan dengan kasus kita. Pada method testCountWords kita membuat instance dari class yang ingin kita test, lalu menjalankan assertEquals.

<strong>Jalankan Test</strong>
<span class="indent"></span>Silahkan buka folder proyek latihan-php-unit lalu jalankan perintah ini :
<pre class="code">
./vendor/bin/phpunit --bootstrap vendor/autoload.php SimpleTest.php
</pre>
<span class="indent"></span>Disini kita memanggil binary program phpunit dan memerintah untuk mengetest file SimpleTest.php yang sudah kita buat sebelumnya. Silahkan pencet enter/run maka hasilnya akan seperti ini :
<img src="https://cdn-cdpl.sgp1.digitaloceanspaces.com/original/120478/8.png" alt="Running PHP Unit">
<span class="indent"></span>Perintah assertEqual akan membandingkan parameter pertama (output yang diinginkan) dan paramater kedua (method yang di run), jika match, berarti test berhasil. Terbayang?

<span class="indent"></span>Kita hanya membandingkan hasil yang diinginkan dengan hasil real output class yang ingin di test. Jika sesuai ekspektasi maka si class tersebut berjalan dengan baik. Jika ternyata pas di test hasil tidak sama, berarti class kita ada bug / error. String "My name is Joko" harus selalu mengeluarkan hasil 4.

<span class="indent"></span>Sampai disini kita sudah berhasil belajar Unit Testing sederhana.
                </pre>
            </li>
            <li class="listboxitem" id="53">
                <h2>Simulasi Unit Testing</h2>
                <pre>
<strong>Simulasi Unit Testing</strong>
<span class="indent"></span>Di samping tes unit ini untuk fungsi dan kelas kecil, kamu perlu menulis tes unit untuk hasil akhir yang dicapai oleh fungsi yang berbeda atau yang lebih besar. Namun, semakin unit test spesifik kamu maka, hasil yang lebih baik dapat kamu dapatkan. Kamu juga harus mengingat bahwa dari banyak tes unit yang kamu tulis, hanya beberapa yang benar-benar berguna. Sekarang kita akan membahas cara menguji rutinitas yang berfungsi dengan basis data. Mari kita buat kelas kecil yang menyisipkan, menemukan, dan memperbarui catatan, yang akan kita tulis untuk unit test. berikut kelas kecil kita, yang secara langsung berinteraksi dengan tabel bernama users di database kita.
<pre class="code">
<span class="tagphpbuka"></span>
    class DB
    {
        private $connection;
    
        public function __construct()
        {
            $this->connection = mysql_connect("localhost","root","root1234");
            mysql_select_db("test",$this->connection);
        }
    
        public function insertData($data)
        {
            $fields = join(array_keys($data),",");
            $values = "'".join(array_values($data),",")."'";
    
            $query = "INSERT INTO users({$fields}) values({$values})";
    
            return mysql_query($query, $this->connection);
        }
    
        public function deleteData($id)
        {
            $query = "delete from users where id={$id}";
    
            return mysql_query($query, $this->connection);
        }
    
        public function updateData($id, $data)
        {
            $queryparts = array();
    
            foreach ($data as $key=>$value)
            {
                $queryparts[] = "{$key} = '{$value}'";
            }
    
            $query = "UPDATE users SET ".join($queryparts,",")." WHERE id='{$id}'";
    
            return mysql_query($query, $this->connection);
        }
    }
    
<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Kita perlu menguji semua metode publik di kelas ini untuk memastikan semua bekerja dengan baik. Jadi, inilah kasus uji kita.
<pre class="code">
<span class="tagphpbuka"></span>
    require_once "PHPUnit/Framework/TestCase.php";

    class DBTester extends PHPUnit_Framework_TestCase {
        private $connection;
        private $Db;
    
        protected function setup()
        {
            $this->Db = new DB();
    
            $this->connection = mysql_connect("localhost","root","root1234");
            mysql_select_db("abcd",$this->connection);
        }
    
        protected  function tearDown()
        {
            mysql_close($this->connection);
        }
    
        public function testValidInsert()
        {
            $data = array("name"=>"afif","pass"=>md5("hello world"));
            mysql_query("delete from users");
    
            $result = $this->Db->insertData($data);
            $this->assertNotNull($result);
    
            $affected_rows = mysql_affected_rows($this->connection);
            $this->assertEquals(1, $affected_rows);
        }
    
        public function testInvalidInsert()
        {
            $data = array("names"=>"afif","passwords"=>md5("hello world"));
            mysql_query("delete from users");
    
            $result = $this->Db->insertData($data);
            $this->assertNotNull($result);
    
            $affected_rows = mysql_affected_rows($this->connection);
            $this->assertEquals(-1, $affected_rows);
        }
    
        public function testUpdate()
        {
            $data = array("name"=>"afif","pass"=>md5("hello world"));
            mysql_query("truncate table users");
    
            $this->Db->insertData($data);
    
            $data = array("name"=>"afif2","pass"=>md5("hello world"));
            $result = $this->Db->updateData(1, $data);
            $this->assertNotNull($result);
    
            $affected_rows = mysql_affected_rows($this->connection);
            $this->assertEquals(1, $affected_rows);
        }
    
        public function testDelete()
        {
            $data = array("name"=>"afif","pass"=>md5("hello world"));
            mysql_query("truncate table users");
    
            $this->Db->insertData($data);
            $result = $this->Db->deleteData(1);
            $this->assertNotNull($result);
    
            $affected_rows = mysql_affected_rows($this->connection);
            $this->assertEquals(1, $affected_rows);
        }
    }

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Test suite adalah seperti ini:
<pre class="code">
<span class="tagphpbuka"></span>

require_once 'PHPUnit/TextUI/TestRunner.php';
require_once "PHPUnit/Framework/TestSuite.php";
$suite = new PHPUnit_Framework_TestSuite();
$suite->addTestSuite("DBTester");

PHPUnit_TextUI_TestRunner::run($suite);

<span class="tagphptutup"></span>
</pre>
<span class="indent"></span>Jadi apa hasil yang akan kita dapatkan?
<pre class="terminal">
PHPUnit 3.0.5 by Sebastian Bergmann.

....

Time: 00:00

OK (4 tests)
</pre>                    
<span class="indent"></span>Namun, ini merupakan tes fungsionalitas dasar. Kita harus melakukan tes yang lebih fleksibel dan mencari tahu bagaimana objek kita bisa gagal. Mari kita tambahkan dua tes lagi seperti yang ditunjukkan di bawah ini:
<pre class="code">
public function testInvalidUpdate() {
    $data = array("name"=>"afif","pass"=>md5("hello world"));
    mysql_query("truncate table users");

    $this->Db->insertData($data);

    $data = array("name"=>"afif2","pass"=>md5("hello world"));
    $result = $this->Db->updateData(2, $data);

    $affected_rows = mysql_affected_rows($this->connection);
    $this->assertEquals(0, $affected_rows);
}

public function testInvalidDelete() {
    $data = array("name"=>"afif","pass"=>md5("hello world"));
    mysql_query("truncate table users");

    $this->Db->insertData($data);
    $result = $this->Db->deleteData("*");
    $this->assertNotNull($result);

    $affected_rows = mysql_affected_rows($this->connection);
    $this->assertEquals(-1, $affected_rows);
}
</pre>
<span class="indent"></span>Sekarang jika Kamu menjalankan test suite Anda akan mendapatkan hasil berikut:
<pre class="terminal">
PHPUnit 3.0.5 by Sebastian Bergmann.

......

Time: 00:00

OK (6 tests)
</pre>
<span class="indent"></span>Kode DB kita akan sulit untuk mengeluarkan Bug.
                    
<span class="indent"></span>Dalam pengujian unit dikehidupan nyata, kamu perlu berpikir keluar bagaimana kamu dapat memecahkan kode kamu sendiri. Jika kamu dapat menulis unit test yang memecahkan kode kamu yang ada, itu lebih baik.
                </pre>
            </li>
            <li class="listboxitem" id="54">
                <h2>Pengantar Test Driven Development</h2>
                <pre>
<span class="indent"></span>Sekarang saatnya untuk melangkah lebih jauh ke dalam unit testing. Kamu mungkin bertanya kapan kamu perlu menulis unit test sebelum pengkodean untuk aplikasi: selama pengembangan, atau setelah menyelesaikan pengkodean? Nah, pengembang dari sudut yang berbeda memiliki hal yang berbeda untuk dibahas, namun ternyata lebih berguna untuk menulis tes terlebih dahulu dan kemudian menuliskan aplikasinya. Singkatnya, ini disebut Test Driven Development atau TDD. TDD membantu kamu merancang API yang lebih baik untuk aplikasi.

<span class="indent"></span>Kamu mungkin bertanya bagaimana menulis tes ketika kamu tidak memiliki kodenya, dan hal-hal apa yang harus diuji? kamu tidak perlu objek nyata untuk TDD. Bayangkan saja beberapa benda tiruan, yang hanya memiliki fungsi. Kamu akan menggunakan fungsi-fungsi itu dengan hasil imajiner. Kamu juga dapat menulis tes tidak lengkap, yang berarti tes dengan tubuh kosong atau tidak sempurna.

<span class="indent"></span>PHPUnit memberi kamu banyak API yang berguna untuk pemrograman pengujian pertama seperti markTestSkipped() dan markTestIncomplete(). Kita akan menggunakan dua metode ini untuk menandai beberapa pengujian kita, yang tidak diterapkan.
                </pre>
            </li>

            <li class="listboxitem" id="lain1">
                <h2>Implode</h2>
                <pre>
<span class="indent"></span>Implode adalah fungsi built-in PHP yang digunakan untuk mengubah elemen array menjadi string.
Cara penulisan:
implode(separator,array);
Keterangan:
- separator: untuk memisahkan string (optional)
- array: adalah array yang hendak di ubah
            </pre>
            </li>
            <li class="listboxitem" id="lain2">
                <h2>Function Time()</h2>
                <pre>
<span class="indent"></span>Fungsi time() adalah bawaan dari php, yang jika kita memanggilnya maka akan mengembalikan return value Waktu saat ini dalam satuan detik, dimana waktu tersebut dimulai sejak January 1 1970 pukul 00:00.
                </pre>
            </li>
            <li class="listboxitem" id="lain3">
                <h2>Error Reporting</h2>
                <pre>
Fungsi :

<pre class="code">
error_reporting(E_ALL);
ini_set('display_errors', 1);
</pre>
<span class="indent"></span>Masing masing untuk mengatur agar PHP mengeluarkan semua jenis error, warning, dst. Supaya memudahkan kita untuk debugging. Pada komputer tertentu biasanya settingan PHP tidak mengeluarkan pesan error. Sehingga sulit belajar, ketika tidak ada error.
                </pre>
            </li>
        </ul>

        <div><a class="backtotop" href="#title">To Top</a></div>
        <script src="script.js"></script>
    </body>
</html>
